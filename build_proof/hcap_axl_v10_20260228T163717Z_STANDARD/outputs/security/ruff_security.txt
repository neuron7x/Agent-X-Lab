S603 `subprocess` call: check for execution of untrusted input
  --> engine/exoneural_governor/util.py:63:12
   |
61 |     ensure_dir(stderr_path.parent)
62 |
63 |     proc = subprocess.run(
   |            ^^^^^^^^^^^^^^
64 |         list(argv),
65 |         cwd=str(cwd),
   |

S603 `subprocess` call: check for execution of untrusted input
  --> engine/scripts/arsenal.py:65:16
   |
63 |         if args.strict:
64 |             cmd.append("--strict")
65 |         return subprocess.run(cmd).returncode
   |                ^^^^^^^^^^^^^^
66 |
67 |     if args.cmd == "eval":
   |

S603 `subprocess` call: check for execution of untrusted input
  --> engine/scripts/arsenal.py:73:16
   |
71 |         if args.write_evidence:
72 |             cmd.append("--write-evidence")
73 |         return subprocess.run(cmd).returncode
   |                ^^^^^^^^^^^^^^
74 |
75 |     if args.cmd == "schema":
   |

S603 `subprocess` call: check for execution of untrusted input
  --> engine/scripts/arsenal.py:77:16
   |
75 |     if args.cmd == "schema":
76 |         cmd = ["python", "scripts/schema_validate.py", "--repo-root", str(root)]
77 |         return subprocess.run(cmd).returncode
   |                ^^^^^^^^^^^^^^
78 |
79 |     if args.cmd == "rebuild":
   |

S603 `subprocess` call: check for execution of untrusted input
  --> engine/scripts/arsenal.py:80:14
   |
79 |     if args.cmd == "rebuild":
80 |         rc = subprocess.run(
   |              ^^^^^^^^^^^^^^
81 |             ["python", "scripts/rebuild_checksums.py", "--repo-root", str(root)]
82 |         ).returncode
   |

S607 Starting a process with a partial executable path
  --> engine/scripts/arsenal.py:81:13
   |
79 |     if args.cmd == "rebuild":
80 |         rc = subprocess.run(
81 |             ["python", "scripts/rebuild_checksums.py", "--repo-root", str(root)]
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
82 |         ).returncode
83 |         if rc != 0:
   |

S603 `subprocess` call: check for execution of untrusted input
  --> engine/scripts/arsenal.py:85:16
   |
83 |         if rc != 0:
84 |             return rc
85 |         return subprocess.run(
   |                ^^^^^^^^^^^^^^
86 |             ["python", "scripts/rebuild_catalog_index.py", "--repo-root", str(root)]
87 |         ).returncode
   |

S607 Starting a process with a partial executable path
  --> engine/scripts/arsenal.py:86:13
   |
84 |             return rc
85 |         return subprocess.run(
86 |             ["python", "scripts/rebuild_catalog_index.py", "--repo-root", str(root)]
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
87 |         ).returncode
   |

S603 `subprocess` call: check for execution of untrusted input
  --> engine/scripts/bootstrap_env.py:14:12
   |
13 | def run_install(req: str) -> int:
14 |     return subprocess.run(
   |            ^^^^^^^^^^^^^^
15 |         [sys.executable, "-m", "pip", "install", "-r", req]
16 |     ).returncode
   |

S603 `subprocess` call: check for execution of untrusted input
  --> engine/scripts/bootstrap_env.py:40:12
   |
38 |     mods = ",".join(REQUIRED_IMPORTS)
39 |     code = "import " + mods
40 |     return subprocess.run([sys.executable, "-c", code]).returncode == 0
   |            ^^^^^^^^^^^^^^
   |

S110 `try`-`except`-`pass` detected, consider logging the exception
   --> engine/scripts/check_prod_spec_gates.py:226:9
    |
224 |           try:
225 |               pbs.append((pb_file, load_json(pb_file)))
226 | /         except Exception:
227 | |             pass
    | |________________^
228 |       # Sort by timestamp
229 |       pbs.sort(key=lambda x: x[1].get("timestamp", ""))
    |

S603 `subprocess` call: check for execution of untrusted input
  --> engine/scripts/generate_proof_bundle.py:21:14
   |
19 | def run_and_log(repo_root: Path, proof_dir: Path, spec: CommandSpec) -> int:
20 |     """Run a command from repo root and write a structured log file."""
21 |     result = subprocess.run(
   |              ^^^^^^^^^^^^^^
22 |         spec.command,
23 |         cwd=repo_root,
   |

S607 Starting a process with a partial executable path
  --> engine/scripts/rebuild_checksums.py:76:9
   |
74 | def _tracked_files(repo_root: Path) -> list[Path]:
75 |     proc = subprocess.run(
76 |         ["git", "ls-files", "-z"],
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^
77 |         cwd=repo_root,
78 |         capture_output=True,
   |

S603 `subprocess` call: check for execution of untrusted input
  --> engine/scripts/run_object_evals.py:40:9
   |
38 |         cmd.append("--write-evidence")
39 |
40 |     p = subprocess.run(cmd, capture_output=True, text=True)
   |         ^^^^^^^^^^^^^^
41 |     out = (p.stdout or "").strip()
42 |     err = (p.stderr or "").strip()
   |

S607 Starting a process with a partial executable path
  --> engine/scripts/validate_arsenal.py:96:9
   |
94 | def _load_tracked_files(repo_root: Path) -> set[str]:
95 |     proc = subprocess.run(
96 |         ["git", "ls-files", "-z"],
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^
97 |         cwd=repo_root,
98 |         capture_output=True,
   |

S603 `subprocess` call: check for execution of untrusted input
   --> engine/scripts/validate_arsenal.py:269:23
    |
267 |             # Evaluate git-tracked files only so local runtime outputs do not cause false failures.
268 |             bad: list[str] = []
269 |             tracked = subprocess.run(
    |                       ^^^^^^^^^^^^^^
270 |                 ["git", "ls-files", str(obj_dir / "artifacts" / "evidence")],
271 |                 cwd=repo_root,
    |

S607 Starting a process with a partial executable path
   --> engine/scripts/validate_arsenal.py:270:17
    |
268 |             bad: list[str] = []
269 |             tracked = subprocess.run(
270 |                 ["git", "ls-files", str(obj_dir / "artifacts" / "evidence")],
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
271 |                 cwd=repo_root,
272 |                 capture_output=True,
    |

S603 `subprocess` call: check for execution of untrusted input
   --> engine/scripts/validate_arsenal.py:311:16
    |
309 |         # --- Schemas (strict)
310 |     if args.strict:
311 |         proc = subprocess.run(
    |                ^^^^^^^^^^^^^^
312 |             [
313 |                 "python",
    |

S607 Starting a process with a partial executable path
   --> engine/scripts/validate_arsenal.py:312:13
    |
310 |       if args.strict:
311 |           proc = subprocess.run(
312 | /             [
313 | |                 "python",
314 | |                 str(repo_root / "scripts" / "schema_validate.py"),
315 | |                 "--repo-root",
316 | |                 str(repo_root),
317 | |             ],
    | |_____________^
318 |               capture_output=True,
319 |               text=True,
    |

S607 Starting a process with a partial executable path
  --> engine/tests/conftest.py:26:9
   |
25 |     p = subprocess.run(
26 |         ["git", "rev-parse", "HEAD"],
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
27 |         capture_output=True,
28 |         text=True,
   |

S101 Use of `assert` detected
  --> engine/tests/conftest.py:64:5
   |
62 |         os.environ[key] = value
63 |
64 |     assert _canonical_env_hash(dict(os.environ)) == environ_before_hash
   |     ^^^^^^
   |

S607 Starting a process with a partial executable path
  --> engine/tests/test_agent_catalog_duplicates.py:12:9
   |
10 | def test_agent_catalog_has_no_identical_content_duplicates() -> None:
11 |     proc = subprocess.run(
12 |         ["python", "scripts/check_agent_duplicate_content.py", "--repo-root", "."],
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 |         cwd=REPO_ROOT,
14 |         capture_output=True,
   |

S101 Use of `assert` detected
  --> engine/tests/test_agent_catalog_duplicates.py:17:5
   |
15 |         text=True,
16 |     )
17 |     assert proc.returncode == 0, proc.stdout + "\n" + proc.stderr
   |     ^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_backend.py:28:5
   |
27 |     msg = str(exc.value)
28 |     assert isinstance(exc.value, RuntimeError)
   |     ^^^^^^
29 |     assert E_BACKEND_TORCH_MISSING in msg
30 |     assert msg == BACKEND_TORCH_MISSING_MESSAGE
   |

S101 Use of `assert` detected
  --> engine/tests/test_backend.py:29:5
   |
27 |     msg = str(exc.value)
28 |     assert isinstance(exc.value, RuntimeError)
29 |     assert E_BACKEND_TORCH_MISSING in msg
   |     ^^^^^^
30 |     assert msg == BACKEND_TORCH_MISSING_MESSAGE
   |

S101 Use of `assert` detected
  --> engine/tests/test_backend.py:30:5
   |
28 |     assert isinstance(exc.value, RuntimeError)
29 |     assert E_BACKEND_TORCH_MISSING in msg
30 |     assert msg == BACKEND_TORCH_MISSING_MESSAGE
   |     ^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_backend.py:47:5
   |
45 |         errors.append(str(exc.value))
46 |
47 |     assert len(set(errors)) == 1
   |     ^^^^^^
48 |     assert errors[0] == BACKEND_TORCH_MISSING_MESSAGE
   |

S101 Use of `assert` detected
  --> engine/tests/test_backend.py:48:5
   |
47 |     assert len(set(errors)) == 1
48 |     assert errors[0] == BACKEND_TORCH_MISSING_MESSAGE
   |     ^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_dependency_review_gate.py:11:5
   |
 9 |     req = tmp_path / "req.txt"
10 |     req.write_text("pkg-a==1.2.3\n# comment\npkg_b==4.5.6\n", encoding="utf-8")
11 |     assert _check_file(req) == []
   |     ^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_dependency_review_gate.py:23:5
   |
21 |     )
22 |     issues = _check_file(req)
23 |     assert len(issues) == 3
   |     ^^^^^^
24 |     assert any("strictly pinned" in issue for issue in issues)
25 |     assert any("non-hermetic" in issue for issue in issues)
   |

S101 Use of `assert` detected
  --> engine/tests/test_dependency_review_gate.py:24:5
   |
22 |     issues = _check_file(req)
23 |     assert len(issues) == 3
24 |     assert any("strictly pinned" in issue for issue in issues)
   |     ^^^^^^
25 |     assert any("non-hermetic" in issue for issue in issues)
   |

S101 Use of `assert` detected
  --> engine/tests/test_dependency_review_gate.py:25:5
   |
23 |     assert len(issues) == 3
24 |     assert any("strictly pinned" in issue for issue in issues)
25 |     assert any("non-hermetic" in issue for issue in issues)
   |     ^^^^^^
   |

S603 `subprocess` call: check for execution of untrusted input
  --> engine/tests/test_doctor.py:10:12
   |
 9 | def test_doctor_passes_in_ci_env() -> None:
10 |     proc = subprocess.run(
   |            ^^^^^^^^^^^^^^
11 |         [__import__("sys").executable, "tools/doctor.py", "--quiet"],
12 |         cwd=REPO_ROOT,
   |

S101 Use of `assert` detected
  --> engine/tests/test_doctor.py:16:5
   |
14 |         text=True,
15 |     )
16 |     assert proc.returncode == 0, proc.stdout + "\n" + proc.stderr
   |     ^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_doctor.py:21:5
   |
19 | def test_quickstart_script_exists_and_executable() -> None:
20 |     path = REPO_ROOT / "scripts/quickstart.sh"
21 |     assert path.exists()
   |     ^^^^^^
22 |     assert path.stat().st_mode & 0o111
   |

S101 Use of `assert` detected
  --> engine/tests/test_doctor.py:22:5
   |
20 |     path = REPO_ROOT / "scripts/quickstart.sh"
21 |     assert path.exists()
22 |     assert path.stat().st_mode & 0o111
   |     ^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_feg_r8_verify.py:16:5
   |
14 |     )
15 |
16 |     assert result["exit"] == 0
   |     ^^^^^^
17 |     assert not sentinel.exists()
18 |     assert result["cmd"]
   |

S101 Use of `assert` detected
  --> engine/tests/test_feg_r8_verify.py:17:5
   |
16 |     assert result["exit"] == 0
17 |     assert not sentinel.exists()
   |     ^^^^^^
18 |     assert result["cmd"]
19 |     assert isinstance(result["log_tail"], list)
   |

S101 Use of `assert` detected
  --> engine/tests/test_feg_r8_verify.py:18:5
   |
16 |     assert result["exit"] == 0
17 |     assert not sentinel.exists()
18 |     assert result["cmd"]
   |     ^^^^^^
19 |     assert isinstance(result["log_tail"], list)
   |

S101 Use of `assert` detected
  --> engine/tests/test_feg_r8_verify.py:19:5
   |
17 |     assert not sentinel.exists()
18 |     assert result["cmd"]
19 |     assert isinstance(result["log_tail"], list)
   |     ^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_generate_proof_bundle.py:12:1
   |
10 | )
11 | SPEC = importlib.util.spec_from_file_location("generate_proof_bundle", MODULE_PATH)
12 | assert SPEC and SPEC.loader
   | ^^^^^^
13 | MODULE = importlib.util.module_from_spec(SPEC)
14 | sys.modules[SPEC.name] = MODULE
   |

S101 Use of `assert` detected
  --> engine/tests/test_generate_proof_bundle.py:30:5
   |
28 |     exit_code = run_and_log(tmp_path, tmp_path, spec)
29 |
30 |     assert exit_code == 0
   |     ^^^^^^
31 |     content = (tmp_path / "sample.log").read_text(encoding="utf-8")
32 |     assert "command: python -c print('ok')" in content
   |

S101 Use of `assert` detected
  --> engine/tests/test_generate_proof_bundle.py:32:5
   |
30 |     assert exit_code == 0
31 |     content = (tmp_path / "sample.log").read_text(encoding="utf-8")
32 |     assert "command: python -c print('ok')" in content
   |     ^^^^^^
33 |     assert "exit_code: 0" in content
34 |     assert "stdout:\nok" in content
   |

S101 Use of `assert` detected
  --> engine/tests/test_generate_proof_bundle.py:33:5
   |
31 |     content = (tmp_path / "sample.log").read_text(encoding="utf-8")
32 |     assert "command: python -c print('ok')" in content
33 |     assert "exit_code: 0" in content
   |     ^^^^^^
34 |     assert "stdout:\nok" in content
35 |     assert "stderr:\n<empty>" in content
   |

S101 Use of `assert` detected
  --> engine/tests/test_generate_proof_bundle.py:34:5
   |
32 |     assert "command: python -c print('ok')" in content
33 |     assert "exit_code: 0" in content
34 |     assert "stdout:\nok" in content
   |     ^^^^^^
35 |     assert "stderr:\n<empty>" in content
   |

S101 Use of `assert` detected
  --> engine/tests/test_generate_proof_bundle.py:35:5
   |
33 |     assert "exit_code: 0" in content
34 |     assert "stdout:\nok" in content
35 |     assert "stderr:\n<empty>" in content
   |     ^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_isolation_fixture.py:26:5
   |
24 |     os.environ[_LEAK_ENV_KEY] = "set-during-test"
25 |
26 |     assert _LEAK_MODULE_NAME in sys.modules
   |     ^^^^^^
27 |     assert _LEAK_MODULE_NAME_SCRIPTS in sys.modules
28 |     assert os.environ[_LEAK_ENV_KEY] == "set-during-test"
   |

S101 Use of `assert` detected
  --> engine/tests/test_isolation_fixture.py:27:5
   |
26 |     assert _LEAK_MODULE_NAME in sys.modules
27 |     assert _LEAK_MODULE_NAME_SCRIPTS in sys.modules
   |     ^^^^^^
28 |     assert os.environ[_LEAK_ENV_KEY] == "set-during-test"
   |

S101 Use of `assert` detected
  --> engine/tests/test_isolation_fixture.py:28:5
   |
26 |     assert _LEAK_MODULE_NAME in sys.modules
27 |     assert _LEAK_MODULE_NAME_SCRIPTS in sys.modules
28 |     assert os.environ[_LEAK_ENV_KEY] == "set-during-test"
   |     ^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_isolation_fixture.py:32:5
   |
31 | def test_isolation_removes_product_module_leaks_and_restores_environment() -> None:
32 |     assert _LEAK_MODULE_NAME not in sys.modules
   |     ^^^^^^
33 |     assert _LEAK_MODULE_NAME_SCRIPTS not in sys.modules
34 |     assert _LEAK_ENV_KEY not in os.environ
   |

S101 Use of `assert` detected
  --> engine/tests/test_isolation_fixture.py:33:5
   |
31 | def test_isolation_removes_product_module_leaks_and_restores_environment() -> None:
32 |     assert _LEAK_MODULE_NAME not in sys.modules
33 |     assert _LEAK_MODULE_NAME_SCRIPTS not in sys.modules
   |     ^^^^^^
34 |     assert _LEAK_ENV_KEY not in os.environ
35 |     assert _stable_environ_snapshot() == {
   |

S101 Use of `assert` detected
  --> engine/tests/test_isolation_fixture.py:34:5
   |
32 |     assert _LEAK_MODULE_NAME not in sys.modules
33 |     assert _LEAK_MODULE_NAME_SCRIPTS not in sys.modules
34 |     assert _LEAK_ENV_KEY not in os.environ
   |     ^^^^^^
35 |     assert _stable_environ_snapshot() == {
36 |         k: v for k, v in _BASE_ENV.items() if k != "PYTEST_CURRENT_TEST"
   |

S101 Use of `assert` detected
  --> engine/tests/test_isolation_fixture.py:35:5
   |
33 |     assert _LEAK_MODULE_NAME_SCRIPTS not in sys.modules
34 |     assert _LEAK_ENV_KEY not in os.environ
35 |     assert _stable_environ_snapshot() == {
   |     ^^^^^^
36 |         k: v for k, v in _BASE_ENV.items() if k != "PYTEST_CURRENT_TEST"
37 |     }
   |

S101 Use of `assert` detected
  --> engine/tests/test_isolation_fixture.py:48:5
   |
46 |     os.environ["AGENTX_PARITY_EXTRA"] = "extra"
47 |
48 |     assert os.environ["PATH"] == "temporary-path-value"
   |     ^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_isolation_fixture.py:52:5
   |
51 | def test_environment_parity_is_strict_after_mutation() -> None:
52 |     assert _stable_environ_snapshot() == {
   |     ^^^^^^
53 |         k: v for k, v in _BASE_ENV.items() if k != "PYTEST_CURRENT_TEST"
54 |     }
   |

S101 Use of `assert` detected
  --> engine/tests/test_network_backend.py:19:5
   |
17 |                 raise AssertionError("Expected RuntimeError when torch is missing")
18 |
19 |     assert msgs[0] == msgs[1] == msgs[2]
   |     ^^^^^^
20 |     assert "E_BACKEND_TORCH_MISSING" in msgs[0]
   |

S101 Use of `assert` detected
  --> engine/tests/test_network_backend.py:20:5
   |
19 |     assert msgs[0] == msgs[1] == msgs[2]
20 |     assert "E_BACKEND_TORCH_MISSING" in msgs[0]
   |     ^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_nongit_runner.py:20:5
   |
18 |     nongit_runner._copy_repo_without_git(src, dst)
19 |
20 |     assert (dst / "module.py").exists()
   |     ^^^^^^
21 |     assert not (dst / ".git").exists()
   |

S101 Use of `assert` detected
  --> engine/tests/test_nongit_runner.py:21:5
   |
20 |     assert (dst / "module.py").exists()
21 |     assert not (dst / ".git").exists()
   |     ^^^^^^
   |

S603 `subprocess` call: check for execution of untrusted input
  --> engine/tests/test_nongit_runner.py:34:12
   |
32 |     )
33 |
34 |     proc = subprocess.run(
   |            ^^^^^^^^^^^^^^
35 |         [
36 |             sys.executable,
   |

S101 Use of `assert` detected
  --> engine/tests/test_nongit_runner.py:51:5
   |
49 |     )
50 |
51 |     assert proc.returncode == 0, proc.stdout + "\n" + proc.stderr
   |     ^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_pip_audit_gate.py:18:5
   |
17 | def test_load_allowlist_empty_when_missing(tmp_path: Path) -> None:
18 |     assert pip_audit_gate._load_allowlist(tmp_path / "missing.json") == []
   |     ^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_pip_audit_gate.py:38:5
   |
36 |     ]
37 |     active, expired = pip_audit_gate._split_allowlist(entries, today=date(2026, 1, 1))
38 |     assert active == ["CVE-2024-0001"]
   |     ^^^^^^
39 |     assert len(expired) == 1
40 |     assert "CVE-2024-0002" in expired[0]
   |

S101 Use of `assert` detected
  --> engine/tests/test_pip_audit_gate.py:39:5
   |
37 |     active, expired = pip_audit_gate._split_allowlist(entries, today=date(2026, 1, 1))
38 |     assert active == ["CVE-2024-0001"]
39 |     assert len(expired) == 1
   |     ^^^^^^
40 |     assert "CVE-2024-0002" in expired[0]
   |

S101 Use of `assert` detected
  --> engine/tests/test_pip_audit_gate.py:40:5
   |
38 |     assert active == ["CVE-2024-0001"]
39 |     assert len(expired) == 1
40 |     assert "CVE-2024-0002" in expired[0]
   |     ^^^^^^
   |

S603 `subprocess` call: check for execution of untrusted input
  --> engine/tests/test_pip_audit_gate.py:49:12
   |
47 |     env = dict(__import__("os").environ)
48 |     env["PIP_AUDIT_FORCE_MISSING"] = "1"
49 |     proc = subprocess.run(
   |            ^^^^^^^^^^^^^^
50 |         [
51 |             sys.executable,
   |

S101 Use of `assert` detected
  --> engine/tests/test_pip_audit_gate.py:65:5
   |
63 |         env=env,
64 |     )
65 |     assert proc.returncode == 3
   |     ^^^^^^
66 |     assert out.exists()
67 |     payload = json.loads(out.read_text(encoding="utf-8"))
   |

S101 Use of `assert` detected
  --> engine/tests/test_pip_audit_gate.py:66:5
   |
64 |     )
65 |     assert proc.returncode == 3
66 |     assert out.exists()
   |     ^^^^^^
67 |     payload = json.loads(out.read_text(encoding="utf-8"))
68 |     assert payload["reason_code"] == "pip-audit-missing"
   |

S101 Use of `assert` detected
  --> engine/tests/test_pip_audit_gate.py:68:5
   |
66 |     assert out.exists()
67 |     payload = json.loads(out.read_text(encoding="utf-8"))
68 |     assert payload["reason_code"] == "pip-audit-missing"
   |     ^^^^^^
69 |     assert payload["remediation"] == "install pip-audit==2.9.0"
70 |     assert payload["status"] == "error"
   |

S101 Use of `assert` detected
  --> engine/tests/test_pip_audit_gate.py:69:5
   |
67 |     payload = json.loads(out.read_text(encoding="utf-8"))
68 |     assert payload["reason_code"] == "pip-audit-missing"
69 |     assert payload["remediation"] == "install pip-audit==2.9.0"
   |     ^^^^^^
70 |     assert payload["status"] == "error"
71 |     assert payload["tool"] == "pip-audit"
   |

S101 Use of `assert` detected
  --> engine/tests/test_pip_audit_gate.py:70:5
   |
68 |     assert payload["reason_code"] == "pip-audit-missing"
69 |     assert payload["remediation"] == "install pip-audit==2.9.0"
70 |     assert payload["status"] == "error"
   |     ^^^^^^
71 |     assert payload["tool"] == "pip-audit"
72 |     assert payload["version"] is None
   |

S101 Use of `assert` detected
  --> engine/tests/test_pip_audit_gate.py:71:5
   |
69 |     assert payload["remediation"] == "install pip-audit==2.9.0"
70 |     assert payload["status"] == "error"
71 |     assert payload["tool"] == "pip-audit"
   |     ^^^^^^
72 |     assert payload["version"] is None
   |

S101 Use of `assert` detected
  --> engine/tests/test_pip_audit_gate.py:72:5
   |
70 |     assert payload["status"] == "error"
71 |     assert payload["tool"] == "pip-audit"
72 |     assert payload["version"] is None
   |     ^^^^^^
   |

S603 `subprocess` call: check for execution of untrusted input
  --> engine/tests/test_pip_audit_gate.py:79:12
   |
77 |     allow = tmp_path / "allow.json"
78 |     allow.write_text('{"ignore": "bad"}\n', encoding="utf-8")
79 |     proc = subprocess.run(
   |            ^^^^^^^^^^^^^^
80 |         [
81 |             sys.executable,
   |

S101 Use of `assert` detected
  --> engine/tests/test_pip_audit_gate.py:94:5
   |
92 |         text=True,
93 |     )
94 |     assert proc.returncode == 4
   |     ^^^^^^
95 |     payload = json.loads(out.read_text(encoding="utf-8"))
96 |     assert payload["reason_code"] == "allowlist-parse-error"
   |

S101 Use of `assert` detected
  --> engine/tests/test_pip_audit_gate.py:96:5
   |
94 |     assert proc.returncode == 4
95 |     payload = json.loads(out.read_text(encoding="utf-8"))
96 |     assert payload["reason_code"] == "allowlist-parse-error"
   |     ^^^^^^
97 |     assert payload["status"] == "error"
98 |     assert payload["tool"] == "pip-audit"
   |

S101 Use of `assert` detected
  --> engine/tests/test_pip_audit_gate.py:97:5
   |
95 |     payload = json.loads(out.read_text(encoding="utf-8"))
96 |     assert payload["reason_code"] == "allowlist-parse-error"
97 |     assert payload["status"] == "error"
   |     ^^^^^^
98 |     assert payload["tool"] == "pip-audit"
99 |     assert payload["version"] is None
   |

S101 Use of `assert` detected
  --> engine/tests/test_pip_audit_gate.py:98:5
   |
96 |     assert payload["reason_code"] == "allowlist-parse-error"
97 |     assert payload["status"] == "error"
98 |     assert payload["tool"] == "pip-audit"
   |     ^^^^^^
99 |     assert payload["version"] is None
   |

S101 Use of `assert` detected
  --> engine/tests/test_pip_audit_gate.py:99:5
   |
97 |     assert payload["status"] == "error"
98 |     assert payload["tool"] == "pip-audit"
99 |     assert payload["version"] is None
   |     ^^^^^^
   |

S101 Use of `assert` detected
   --> engine/tests/test_pip_audit_gate.py:111:5
    |
109 |         3,
110 |     )
111 |     assert rc == 3
    |     ^^^^^^
112 |     payload = json.loads(out.read_text(encoding="utf-8"))
113 |     assert payload["reason_code"] == "pip-audit-missing"
    |

S101 Use of `assert` detected
   --> engine/tests/test_pip_audit_gate.py:113:5
    |
111 |     assert rc == 3
112 |     payload = json.loads(out.read_text(encoding="utf-8"))
113 |     assert payload["reason_code"] == "pip-audit-missing"
    |     ^^^^^^
114 |     assert payload["remediation"] == "install pip-audit==2.9.0"
    |

S101 Use of `assert` detected
   --> engine/tests/test_pip_audit_gate.py:114:5
    |
112 |     payload = json.loads(out.read_text(encoding="utf-8"))
113 |     assert payload["reason_code"] == "pip-audit-missing"
114 |     assert payload["remediation"] == "install pip-audit==2.9.0"
    |     ^^^^^^
    |

S603 `subprocess` call: check for execution of untrusted input
   --> engine/tests/test_pip_audit_gate.py:135:12
    |
133 |         encoding="utf-8",
134 |     )
135 |     proc = subprocess.run(
    |            ^^^^^^^^^^^^^^
136 |         [
137 |             sys.executable,
    |

S101 Use of `assert` detected
   --> engine/tests/test_pip_audit_gate.py:150:5
    |
148 |         text=True,
149 |     )
150 |     assert proc.returncode == 2
    |     ^^^^^^
151 |     payload = json.loads(out.read_text(encoding="utf-8"))
152 |     assert payload["reason_code"] == "allowlist-expired"
    |

S101 Use of `assert` detected
   --> engine/tests/test_pip_audit_gate.py:152:5
    |
150 |     assert proc.returncode == 2
151 |     payload = json.loads(out.read_text(encoding="utf-8"))
152 |     assert payload["reason_code"] == "allowlist-expired"
    |     ^^^^^^
153 |     assert payload["status"] == "error"
154 |     assert payload["tool"] == "pip-audit"
    |

S101 Use of `assert` detected
   --> engine/tests/test_pip_audit_gate.py:153:5
    |
151 |     payload = json.loads(out.read_text(encoding="utf-8"))
152 |     assert payload["reason_code"] == "allowlist-expired"
153 |     assert payload["status"] == "error"
    |     ^^^^^^
154 |     assert payload["tool"] == "pip-audit"
155 |     assert payload["expired_entries"] == [
    |

S101 Use of `assert` detected
   --> engine/tests/test_pip_audit_gate.py:154:5
    |
152 |     assert payload["reason_code"] == "allowlist-expired"
153 |     assert payload["status"] == "error"
154 |     assert payload["tool"] == "pip-audit"
    |     ^^^^^^
155 |     assert payload["expired_entries"] == [
156 |         "CVE-2020-0001 (expires=2020-01-01, reason=temporary)"
    |

S101 Use of `assert` detected
   --> engine/tests/test_pip_audit_gate.py:155:5
    |
153 |     assert payload["status"] == "error"
154 |     assert payload["tool"] == "pip-audit"
155 |     assert payload["expired_entries"] == [
    |     ^^^^^^
156 |         "CVE-2020-0001 (expires=2020-01-01, reason=temporary)"
157 |     ]
    |

S101 Use of `assert` detected
  --> engine/tests/test_protocol_step_paths.py:36:9
   |
34 |     for step_id, deficit_id in expected.items():
35 |         step = steps.get(step_id)
36 |         assert step is not None, f"missing step: {step_id}"
   |         ^^^^^^
37 |         assert deficit_id in (step.get("fixes") or []), (
38 |             f"{step_id} must fix {deficit_id}"
   |

S101 Use of `assert` detected
  --> engine/tests/test_protocol_step_paths.py:37:9
   |
35 |         step = steps.get(step_id)
36 |         assert step is not None, f"missing step: {step_id}"
37 |         assert deficit_id in (step.get("fixes") or []), (
   |         ^^^^^^
38 |             f"{step_id} must fix {deficit_id}"
39 |         )
   |

S101 Use of `assert` detected
  --> engine/tests/test_protocol_step_paths.py:42:9
   |
41 |         impl_paths = [p for p in (step.get("impl_paths") or []) if isinstance(p, str)]
42 |         assert impl_paths, f"{step_id} must declare impl_paths"
   |         ^^^^^^
43 |         missing = [p for p in impl_paths if not (REPO_ROOT / p).exists()]
44 |         assert missing == [], f"{step_id} has missing impl paths: {missing}"
   |

S101 Use of `assert` detected
  --> engine/tests/test_protocol_step_paths.py:44:9
   |
42 |         assert impl_paths, f"{step_id} must declare impl_paths"
43 |         missing = [p for p in impl_paths if not (REPO_ROOT / p).exists()]
44 |         assert missing == [], f"{step_id} has missing impl paths: {missing}"
   |         ^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_protocol_step_paths.py:54:5
   |
52 |         if not [p for p in (step.get("impl_paths") or []) if isinstance(p, str)]
53 |     ]
54 |     assert missing == [], f"steps without impl_paths: {missing}"
   |     ^^^^^^
   |

S603 `subprocess` call: check for execution of untrusted input
  --> engine/tests/test_readme_contract.py:15:12
   |
14 | def run(cmd: list[str], cwd: Path = ENGINE_ROOT) -> subprocess.CompletedProcess[str]:
15 |     return subprocess.run(cmd, cwd=cwd, capture_output=True, text=True)
   |            ^^^^^^^^^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_readme_contract.py:51:5
   |
49 |         ]
50 |     )
51 |     assert p.returncode == 0, p.stdout + "\n" + p.stderr
   |     ^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_readme_contract.py:67:5
   |
65 |         cwd=repo_copy,
66 |     )
67 |     assert inv.returncode == 0, inv.stdout + "\n" + inv.stderr
   |     ^^^^^^
68 |
69 |     p = run(
   |

S101 Use of `assert` detected
  --> engine/tests/test_readme_contract.py:82:5
   |
80 |         cwd=repo_copy,
81 |     )
82 |     assert p.returncode == 0, p.stdout + "\n" + p.stderr
   |     ^^^^^^
   |

S101 Use of `assert` detected
   --> engine/tests/test_readme_contract.py:145:13
    |
143 |                 cwd=temp_path,
144 |             )
145 |             assert proc.returncode != 0
    |             ^^^^^^
146 |             outputs.append(proc.stderr.strip())
    |

S101 Use of `assert` detected
   --> engine/tests/test_readme_contract.py:148:5
    |
146 |             outputs.append(proc.stderr.strip())
147 |
148 |     assert outputs == [expected, expected, expected]
    |     ^^^^^^
    |

S101 Use of `assert` detected
   --> engine/tests/test_readme_contract.py:154:5
    |
152 |     repo_copy = _copy_engine_repo_for_test(tmp_path)
153 |     p = run(["python", "tools/generate_titan9_proof.py", "--repo-root", "."], cwd=repo_copy)
154 |     assert p.returncode == 0, p.stdout + "\n" + p.stderr
    |     ^^^^^^
155 |
156 |     for rel in [
    |

S101 Use of `assert` detected
   --> engine/tests/test_readme_contract.py:162:9
    |
160 |         "artifacts/titan9/hashes.json",
161 |     ]:
162 |         assert (repo_copy / rel).exists(), rel
    |         ^^^^^^
    |

S603 `subprocess` call: check for execution of untrusted input
  --> engine/tests/test_rebuild_catalog_index.py:14:12
   |
13 | def run_rebuild(repo_root: Path) -> subprocess.CompletedProcess[str]:
14 |     return subprocess.run(
   |            ^^^^^^^^^^^^^^
15 |         [
16 |             sys.executable,
   |

S101 Use of `assert` detected
  --> engine/tests/test_rebuild_catalog_index.py:37:5
   |
36 |     first = run_rebuild(repo_copy)
37 |     assert first.returncode == 0, first.stdout + "\n" + first.stderr
   |     ^^^^^^
38 |
39 |     second = run_rebuild(repo_copy)
   |

S101 Use of `assert` detected
  --> engine/tests/test_rebuild_catalog_index.py:40:5
   |
39 |     second = run_rebuild(repo_copy)
40 |     assert second.returncode == 0, second.stdout + "\n" + second.stderr
   |     ^^^^^^
41 |
42 |     rebuilt = json.loads(index_path.read_text(encoding="utf-8"))
   |

S101 Use of `assert` detected
  --> engine/tests/test_rebuild_catalog_index.py:43:5
   |
42 |     rebuilt = json.loads(index_path.read_text(encoding="utf-8"))
43 |     assert rebuilt["generated_utc"] == original_generated_utc
   |     ^^^^^^
   |

S603 `subprocess` call: check for execution of untrusted input
  --> engine/tests/test_rebuild_checksums.py:13:12
   |
12 | def run_rebuild(repo_root: Path) -> subprocess.CompletedProcess[str]:
13 |     return subprocess.run(
   |            ^^^^^^^^^^^^^^
14 |         [
15 |             sys.executable,
   |

S607 Starting a process with a partial executable path
  --> engine/tests/test_rebuild_checksums.py:28:9
   |
26 | def test_rebuild_checksums_excludes_transient_artifact_paths(tmp_path: Path) -> None:
27 |     subprocess.run(
28 |         ["git", "init"], cwd=tmp_path, check=True, capture_output=True, text=True
   |         ^^^^^^^^^^^^^^^
29 |     )
30 |     subprocess.run(
   |

S607 Starting a process with a partial executable path
  --> engine/tests/test_rebuild_checksums.py:31:9
   |
29 |     )
30 |     subprocess.run(
31 |         ["git", "config", "user.email", "test@example.com"],
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
32 |         cwd=tmp_path,
33 |         check=True,
   |

S607 Starting a process with a partial executable path
  --> engine/tests/test_rebuild_checksums.py:38:9
   |
36 |     )
37 |     subprocess.run(
38 |         ["git", "config", "user.name", "Test User"],
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
39 |         cwd=tmp_path,
40 |         check=True,
   |

S607 Starting a process with a partial executable path
  --> engine/tests/test_rebuild_checksums.py:78:9
   |
77 |       subprocess.run(
78 | /         [
79 | |             "git",
80 | |             "add",
81 | |             "src/stable.txt",
82 | |             "objects/x/artifacts/evidence/reference/eval/report.json",
83 | |             "MANIFEST.json",
84 | |         ],
   | |_________^
85 |           cwd=tmp_path,
86 |           check=True,
   |

S101 Use of `assert` detected
  --> engine/tests/test_rebuild_checksums.py:92:5
   |
91 |     proc = run_rebuild(tmp_path)
92 |     assert proc.returncode == 0, proc.stdout + "\n" + proc.stderr
   |     ^^^^^^
93 |
94 |     manifest = json.loads((tmp_path / "MANIFEST.json").read_text(encoding="utf-8"))
   |

S101 Use of `assert` detected
  --> engine/tests/test_rebuild_checksums.py:96:5
   |
94 |     manifest = json.loads((tmp_path / "MANIFEST.json").read_text(encoding="utf-8"))
95 |     checksums = manifest["checksums"]
96 |     assert "src/stable.txt" in checksums
   |     ^^^^^^
97 |     assert "objects/x/artifacts/evidence/reference/eval/report.json" in checksums
   |

S101 Use of `assert` detected
  --> engine/tests/test_rebuild_checksums.py:97:5
   |
95 |     checksums = manifest["checksums"]
96 |     assert "src/stable.txt" in checksums
97 |     assert "objects/x/artifacts/evidence/reference/eval/report.json" in checksums
   |     ^^^^^^
98 |
99 |     bad_prefixes = [
   |

S101 Use of `assert` detected
   --> engine/tests/test_rebuild_checksums.py:109:5
    |
107 |         if any(path.startswith(prefix) for prefix in bad_prefixes)
108 |     ]
109 |     assert bad_paths == [], f"transient artifact paths must be excluded: {bad_paths}"
    |     ^^^^^^
    |

S607 Starting a process with a partial executable path
   --> engine/tests/test_rebuild_checksums.py:114:9
    |
112 | def test_rebuild_checksums_uses_git_tracked_files_only(tmp_path: Path) -> None:
113 |     subprocess.run(
114 |         ["git", "init"], cwd=tmp_path, check=True, capture_output=True, text=True
    |         ^^^^^^^^^^^^^^^
115 |     )
116 |     subprocess.run(
    |

S607 Starting a process with a partial executable path
   --> engine/tests/test_rebuild_checksums.py:117:9
    |
115 |     )
116 |     subprocess.run(
117 |         ["git", "config", "user.email", "test@example.com"],
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
118 |         cwd=tmp_path,
119 |         check=True,
    |

S607 Starting a process with a partial executable path
   --> engine/tests/test_rebuild_checksums.py:124:9
    |
122 |     )
123 |     subprocess.run(
124 |         ["git", "config", "user.name", "Test User"],
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
125 |         cwd=tmp_path,
126 |         check=True,
    |

S607 Starting a process with a partial executable path
   --> engine/tests/test_rebuild_checksums.py:147:9
    |
145 |     )
146 |     subprocess.run(
147 |         ["git", "add", "tracked.txt", "MANIFEST.json"],
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
148 |         cwd=tmp_path,
149 |         check=True,
    |

S101 Use of `assert` detected
   --> engine/tests/test_rebuild_checksums.py:157:5
    |
156 |     proc = run_rebuild(tmp_path)
157 |     assert proc.returncode == 0, proc.stdout + "\n" + proc.stderr
    |     ^^^^^^
158 |
159 |     manifest = json.loads((tmp_path / "MANIFEST.json").read_text(encoding="utf-8"))
    |

S101 Use of `assert` detected
   --> engine/tests/test_rebuild_checksums.py:161:5
    |
159 |     manifest = json.loads((tmp_path / "MANIFEST.json").read_text(encoding="utf-8"))
160 |     checksums = manifest["checksums"]
161 |     assert "tracked.txt" in checksums
    |     ^^^^^^
162 |     assert "untracked.txt" not in checksums
    |

S101 Use of `assert` detected
   --> engine/tests/test_rebuild_checksums.py:162:5
    |
160 |     checksums = manifest["checksums"]
161 |     assert "tracked.txt" in checksums
162 |     assert "untracked.txt" not in checksums
    |     ^^^^^^
    |

S101 Use of `assert` detected
  --> engine/tests/test_redaction.py:38:5
   |
36 |     second = redact_tree(root, ["SECRET"])
37 |
38 |     assert first == expected
   |     ^^^^^^
39 |     assert second == expected
   |

S101 Use of `assert` detected
  --> engine/tests/test_redaction.py:39:5
   |
38 |     assert first == expected
39 |     assert second == expected
   |     ^^^^^^
   |

S603 `subprocess` call: check for execution of untrusted input
  --> engine/tests/test_repo_invariants.py:12:12
   |
11 | def run(cmd: list[str]) -> subprocess.CompletedProcess[str]:
12 |     return subprocess.run(cmd, cwd=REPO_ROOT, capture_output=True, text=True)
   |            ^^^^^^^^^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_repo_invariants.py:22:5
   |
20 | def test_validate_arsenal_strict_passes() -> None:
21 |     p = run(["python", "scripts/validate_arsenal.py", "--repo-root", ".", "--strict"])
22 |     assert p.returncode in (0, 1), p.stdout + "\n" + p.stderr
   |     ^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_repo_invariants.py:27:5
   |
25 | def test_schema_validate_passes() -> None:
26 |     p = run(["python", "scripts/schema_validate.py", "--repo-root", "."])
27 |     assert p.returncode == 0, p.stdout + "\n" + p.stderr
   |     ^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_repo_invariants.py:32:5
   |
30 | def test_object_eval_harnesses_pass() -> None:
31 |     p = run(["python", "scripts/run_object_evals.py", "--repo-root", "."])
32 |     assert p.returncode == 0, p.stdout + "\n" + p.stderr
   |     ^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_repo_invariants.py:41:5
   |
39 |         pytest.skip("requires git checkout")
40 |     p = run(["git", "ls-files"])
41 |     assert p.returncode == 0, p.stderr
   |     ^^^^^^
42 |     tracked = p.stdout.splitlines()
43 |     forbidden = [
   |

S101 Use of `assert` detected
  --> engine/tests/test_repo_invariants.py:55:5
   |
53 |         )
54 |     ]
55 |     assert forbidden == [], f"forbidden tracked artifacts: {forbidden}"
   |     ^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_repo_invariants.py:65:5
   |
63 |     ]
64 |     missing = [str(p.relative_to(WORKFLOW_ROOT)) for p in required if not p.exists()]
65 |     assert missing == [], f"missing workflows: {missing}"
   |     ^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_repo_invariants.py:71:9
   |
69 |     makefile = (REPO_ROOT / "Makefile").read_text(encoding="utf-8")
70 |     for target in ["fmt", "lint", "type", "test", "validate", "eval", "ci"]:
71 |         assert f"{target}:" in makefile
   |         ^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_repo_invariants.py:85:5
   |
83 |         ]
84 |     )
85 |     assert p.returncode in (0, 2), p.stdout + "\n" + p.stderr
   |     ^^^^^^
   |

S101 Use of `assert` detected
   --> engine/tests/test_repo_invariants.py:102:5
    |
100 |         ]
101 |     )
102 |     assert p.returncode in (0, 3), p.stdout + "\n" + p.stderr
    |     ^^^^^^
103 |     assert "unrecognized arguments" not in (p.stdout + p.stderr)
    |

S101 Use of `assert` detected
   --> engine/tests/test_repo_invariants.py:103:5
    |
101 |     )
102 |     assert p.returncode in (0, 3), p.stdout + "\n" + p.stderr
103 |     assert "unrecognized arguments" not in (p.stdout + p.stderr)
    |     ^^^^^^
    |

S101 Use of `assert` detected
   --> engine/tests/test_repo_invariants.py:121:5
    |
119 |         ]
120 |     )
121 |     assert p.returncode == 0, p.stdout + "\n" + p.stderr
    |     ^^^^^^
    |

S101 Use of `assert` detected
   --> engine/tests/test_repo_invariants.py:138:5
    |
136 |         or p.startswith("artifacts/agent/")
137 |     ]
138 |     assert bad == [], f"transient artifacts must not be checksummed: {bad}"
    |     ^^^^^^
    |

S603 `subprocess` call: check for execution of untrusted input
  --> engine/tests/test_run_gate.py:21:12
   |
19 |     env = dict(os.environ)
20 |     env["AXL_EVIDENCE_ROOT"] = str(evidence_root)
21 |     proc = subprocess.run(
   |            ^^^^^^^^^^^^^^
22 |         [
23 |             "python",
   |

S607 Starting a process with a partial executable path
  --> engine/tests/test_run_gate.py:22:9
   |
20 |       env["AXL_EVIDENCE_ROOT"] = str(evidence_root)
21 |       proc = subprocess.run(
22 | /         [
23 | |             "python",
24 | |             str(REPO_ROOT / "tools" / "run_gate.py"),
25 | |             "--gate-id",
26 | |             "T",
27 | |             "--cwd",
28 | |             str(target_cwd),
29 | |             "--stdout",
30 | |             str(stdout),
31 | |             "--stderr",
32 | |             str(stderr),
33 | |             "--",
34 | |             "python",
35 | |             "-c",
36 | |             "print('ok')",
37 | |         ],
   | |_________^
38 |           cwd=run_cwd,
39 |           capture_output=True,
   |

S101 Use of `assert` detected
  --> engine/tests/test_run_gate.py:44:5
   |
42 |         env=env,
43 |     )
44 |     assert proc.returncode == 0, proc.stdout + "\n" + proc.stderr
   |     ^^^^^^
   |

S603 `subprocess` call: check for execution of untrusted input
  --> engine/tests/test_run_gate.py:57:12
   |
55 |     env = dict(os.environ)
56 |     env["AXL_EVIDENCE_ROOT"] = str(evidence_root)
57 |     proc = subprocess.run(
   |            ^^^^^^^^^^^^^^
58 |         [
59 |             "python",
   |

S607 Starting a process with a partial executable path
  --> engine/tests/test_run_gate.py:58:9
   |
56 |       env["AXL_EVIDENCE_ROOT"] = str(evidence_root)
57 |       proc = subprocess.run(
58 | /         [
59 | |             "python",
60 | |             str(REPO_ROOT / "tools" / "run_gate.py"),
61 | |             "--gate-id",
62 | |             "T",
63 | |             "--cwd",
64 | |             str(target_cwd),
65 | |             "--stdout",
66 | |             str(stdout),
67 | |             "--stderr",
68 | |             str(stderr),
69 | |             "--evidence-file",
70 | |             evidence_file,
71 | |             "--",
72 | |             "python",
73 | |             "-c",
74 | |             "print('ok')",
75 | |         ],
   | |_________^
76 |           cwd=run_cwd,
77 |           capture_output=True,
   |

S101 Use of `assert` detected
  --> engine/tests/test_run_gate.py:82:5
   |
80 |         env=env,
81 |     )
82 |     assert proc.returncode == 0, proc.stdout + "\n" + proc.stderr
   |     ^^^^^^
   |

S101 Use of `assert` detected
   --> engine/tests/test_run_gate.py:102:5
    |
100 |     )
101 |
102 |     assert evidence.exists()
    |     ^^^^^^
103 |     after = evidence.read_text(encoding="utf-8")
104 |     assert len(after) > len(before)
    |

S101 Use of `assert` detected
   --> engine/tests/test_run_gate.py:104:5
    |
102 |     assert evidence.exists()
103 |     after = evidence.read_text(encoding="utf-8")
104 |     assert len(after) > len(before)
    |     ^^^^^^
105 |     assert not (run_cwd / "artifacts" / "agent" / "evidence.jsonl").exists()
    |

S101 Use of `assert` detected
   --> engine/tests/test_run_gate.py:105:5
    |
103 |     after = evidence.read_text(encoding="utf-8")
104 |     assert len(after) > len(before)
105 |     assert not (run_cwd / "artifacts" / "agent" / "evidence.jsonl").exists()
    |     ^^^^^^
    |

S101 Use of `assert` detected
   --> engine/tests/test_run_gate.py:135:5
    |
134 |     lines = evidence.read_text(encoding="utf-8")[len(start) :].strip().splitlines()
135 |     assert len(lines) >= 2
    |     ^^^^^^
136 |     assert not (run_cwd_a / "artifacts" / "agent" / "evidence.jsonl").exists()
137 |     assert not (run_cwd_b / "artifacts" / "agent" / "evidence.jsonl").exists()
    |

S101 Use of `assert` detected
   --> engine/tests/test_run_gate.py:136:5
    |
134 |     lines = evidence.read_text(encoding="utf-8")[len(start) :].strip().splitlines()
135 |     assert len(lines) >= 2
136 |     assert not (run_cwd_a / "artifacts" / "agent" / "evidence.jsonl").exists()
    |     ^^^^^^
137 |     assert not (run_cwd_b / "artifacts" / "agent" / "evidence.jsonl").exists()
138 |     _ = json.loads(lines[-1])
    |

S101 Use of `assert` detected
   --> engine/tests/test_run_gate.py:137:5
    |
135 |     assert len(lines) >= 2
136 |     assert not (run_cwd_a / "artifacts" / "agent" / "evidence.jsonl").exists()
137 |     assert not (run_cwd_b / "artifacts" / "agent" / "evidence.jsonl").exists()
    |     ^^^^^^
138 |     _ = json.loads(lines[-1])
    |

S101 Use of `assert` detected
   --> engine/tests/test_run_gate.py:159:5
    |
157 |     )
158 |
159 |     assert repo_evidence_path.exists()
    |     ^^^^^^
160 |     assert not (run_cwd / rel_evidence).exists()
    |

S101 Use of `assert` detected
   --> engine/tests/test_run_gate.py:160:5
    |
159 |     assert repo_evidence_path.exists()
160 |     assert not (run_cwd / rel_evidence).exists()
    |     ^^^^^^
    |

S101 Use of `assert` detected
  --> engine/tests/test_secret_scan_gate.py:12:5
   |
10 |     file.write_text("-----BEGIN PRIVATE KEY-----\n", encoding="utf-8")
11 |     findings = _scan_file(file, tmp_path)
12 |     assert findings
   |     ^^^^^^
13 |     assert findings[0]["rule"] == "private_key"
   |

S101 Use of `assert` detected
  --> engine/tests/test_secret_scan_gate.py:13:5
   |
11 |     findings = _scan_file(file, tmp_path)
12 |     assert findings
13 |     assert findings[0]["rule"] == "private_key"
   |     ^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_secret_scan_gate.py:19:5
   |
17 |     file = tmp_path / "b.txt"
18 |     file.write_text("hello world\n", encoding="utf-8")
19 |     assert _scan_file(file, tmp_path) == []
   |     ^^^^^^
   |

S607 Starting a process with a partial executable path
  --> engine/tests/test_stack.py:22:9
   |
20 | def _git_head_available(repo_root: Path) -> bool:
21 |     probe = subprocess.run(
22 |         ["git", "rev-parse", "HEAD"],
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
23 |         cwd=repo_root,
24 |         capture_output=True,
   |

S101 Use of `assert` detected
  --> engine/tests/test_stack.py:64:5
   |
62 |     repo_root = _repo_copy(tmp_path)
63 |     rep = validate_catalog(repo_root)
64 |     assert rep["ok"], rep
   |     ^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_stack.py:76:5
   |
74 |     cfg = load_config(cfg_path)
75 |     vr = run_vr(cfg, write_back=False)
76 |     assert vr["status"] in ("RUN", "CALIBRATION_REQUIRED")
   |     ^^^^^^
77 |
78 |     rel = build_release(cfg, output_dir=out_dir)
   |

S101 Use of `assert` detected
  --> engine/tests/test_stack.py:79:5
   |
78 |     rel = build_release(cfg, output_dir=out_dir)
79 |     assert (repo_root / rel["zip_path"]).exists()
   |     ^^^^^^
   |

S101 Use of `assert` detected
   --> engine/tests/test_stack.py:99:9
    |
 97 |     zip_path = repo_root / rep["zip_path"]
 98 |     with zipfile.ZipFile(zip_path) as zf:
 99 |         assert "evidence/proof.txt" in set(zf.namelist())
    |         ^^^^^^
100 |     assert rep["evidence_included"] is True
    |

S101 Use of `assert` detected
   --> engine/tests/test_stack.py:100:5
    |
 98 |     with zipfile.ZipFile(zip_path) as zf:
 99 |         assert "evidence/proof.txt" in set(zf.namelist())
100 |     assert rep["evidence_included"] is True
    |     ^^^^^^
    |

S101 Use of `assert` detected
   --> engine/tests/test_stack.py:133:5
    |
132 |     rep = build_release(_cfg_for_repo(repo_root), vr_path=vr_path, output_dir=out_dir)
133 |     assert rep["evidence_included"] is False
    |     ^^^^^^
    |

S101 Use of `assert` detected
   --> engine/tests/test_stack.py:146:5
    |
145 |     rep = build_release(_cfg_for_repo(repo_root), vr_path=vr_path, output_dir=out_dir)
146 |     assert rep["evidence_included"] is False
    |     ^^^^^^
    |

S101 Use of `assert` detected
  --> engine/tests/test_titan9_inventory.py:23:5
   |
21 |     )
22 |     commands = _parse_workflow_commands(tmp_path)
23 |     assert any(c.startswith("inline-script sha256:") for c in commands)
   |     ^^^^^^
24 |     assert not any("super-secret-body" in c for c in commands)
   |

S101 Use of `assert` detected
  --> engine/tests/test_titan9_inventory.py:24:5
   |
22 |     commands = _parse_workflow_commands(tmp_path)
23 |     assert any(c.startswith("inline-script sha256:") for c in commands)
24 |     assert not any("super-secret-body" in c for c in commands)
   |     ^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_titan9_inventory.py:45:5
   |
43 |     )
44 |     commands = _parse_workflow_commands(tmp_path)
45 |     assert "cat > out.json <<'JSON'" in commands
   |     ^^^^^^
46 |     assert "echo done" in commands
47 |     assert not any("large-body" in c for c in commands)
   |

S101 Use of `assert` detected
  --> engine/tests/test_titan9_inventory.py:46:5
   |
44 |     commands = _parse_workflow_commands(tmp_path)
45 |     assert "cat > out.json <<'JSON'" in commands
46 |     assert "echo done" in commands
   |     ^^^^^^
47 |     assert not any("large-body" in c for c in commands)
   |

S101 Use of `assert` detected
  --> engine/tests/test_titan9_inventory.py:47:5
   |
45 |     assert "cat > out.json <<'JSON'" in commands
46 |     assert "echo done" in commands
47 |     assert not any("large-body" in c for c in commands)
   |     ^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_titan9_inventory.py:65:5
   |
63 |     )
64 |     commands = _parse_workflow_commands(tmp_path)
65 |     assert any(c.startswith("inline-script sha256:") for c in commands)
   |     ^^^^^^
66 |     assert not any("dangerous" in c for c in commands)
   |

S101 Use of `assert` detected
  --> engine/tests/test_titan9_inventory.py:66:5
   |
64 |     commands = _parse_workflow_commands(tmp_path)
65 |     assert any(c.startswith("inline-script sha256:") for c in commands)
66 |     assert not any("dangerous" in c for c in commands)
   |     ^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_verify_protocol_consistency.py:24:5
   |
22 |     result = verify(protocol)
23 |
24 |     assert result["pass"] is False
   |     ^^^^^^
25 |     assert result["duplicate_deficits"] == []
26 |     assert result["orphan_steps"] == []
   |

S101 Use of `assert` detected
  --> engine/tests/test_verify_protocol_consistency.py:25:5
   |
24 |     assert result["pass"] is False
25 |     assert result["duplicate_deficits"] == []
   |     ^^^^^^
26 |     assert result["orphan_steps"] == []
27 |     assert result["missing_deficits"] == ["D_UNKNOWN"]
   |

S101 Use of `assert` detected
  --> engine/tests/test_verify_protocol_consistency.py:26:5
   |
24 |     assert result["pass"] is False
25 |     assert result["duplicate_deficits"] == []
26 |     assert result["orphan_steps"] == []
   |     ^^^^^^
27 |     assert result["missing_deficits"] == ["D_UNKNOWN"]
   |

S101 Use of `assert` detected
  --> engine/tests/test_verify_protocol_consistency.py:27:5
   |
25 |     assert result["duplicate_deficits"] == []
26 |     assert result["orphan_steps"] == []
27 |     assert result["missing_deficits"] == ["D_UNKNOWN"]
   |     ^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_vr_provenance_id.py:64:5
   |
62 |     second = _work_id(repo_root, cfg)
63 |
64 |     assert first == second
   |     ^^^^^^
65 |     assert first.startswith("release-0.0.0+nogit.")
66 |     assert re.fullmatch(r"release-0\.0\.0\+nogit\.[0-9a-f]{32}", first)
   |

S101 Use of `assert` detected
  --> engine/tests/test_vr_provenance_id.py:65:5
   |
64 |     assert first == second
65 |     assert first.startswith("release-0.0.0+nogit.")
   |     ^^^^^^
66 |     assert re.fullmatch(r"release-0\.0\.0\+nogit\.[0-9a-f]{32}", first)
   |

S101 Use of `assert` detected
  --> engine/tests/test_vr_provenance_id.py:66:5
   |
64 |     assert first == second
65 |     assert first.startswith("release-0.0.0+nogit.")
66 |     assert re.fullmatch(r"release-0\.0\.0\+nogit\.[0-9a-f]{32}", first)
   |     ^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_vr_provenance_id.py:86:5
   |
84 |     spec.write_text("# heading\n titan-9   r7  protocol   spec \n", encoding="utf-8")
85 |
86 |     assert _spec_token(repo_root) == "TITAN-9 R7 PROTOCOL SPEC"
   |     ^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_vr_provenance_id.py:97:5
   |
95 |     token_a = _spec_token(repo_root)
96 |     token_b = _spec_token(repo_root)
97 |     assert token_a == token_b
   |     ^^^^^^
98 |     assert re.fullmatch(r"[0-9a-f]{64}", token_a)
   |

S101 Use of `assert` detected
  --> engine/tests/test_vr_provenance_id.py:98:5
   |
96 |     token_b = _spec_token(repo_root)
97 |     assert token_a == token_b
98 |     assert re.fullmatch(r"[0-9a-f]{64}", token_a)
   |     ^^^^^^
   |

S101 Use of `assert` detected
   --> engine/tests/test_vr_provenance_id.py:134:5
    |
132 |         )
133 |
134 |     assert len(ids) == runs
    |     ^^^^^^
    |

S603 `subprocess` call: check for execution of untrusted input
  --> engine/tests/test_witness.py:22:12
   |
20 |     (base / "minimality" / "trace.jsonl").write_text('{"trial":1}\n', encoding="utf-8")
21 |
22 |     proc = subprocess.run(
   |            ^^^^^^^^^^^^^^
23 |         [sys.executable, "tools/witness.py"],
24 |         cwd=REPO_ROOT,
   |

S101 Use of `assert` detected
  --> engine/tests/test_witness.py:28:5
   |
26 |         text=True,
27 |     )
28 |     assert proc.returncode == 0, proc.stdout + "\n" + proc.stderr
   |     ^^^^^^
29 |
30 |     report = json.loads(
   |

S101 Use of `assert` detected
  --> engine/tests/test_witness.py:34:5
   |
32 |     )
33 |     sig = (base / "attestation" / "witness_sig.txt").read_text(encoding="utf-8").strip()
34 |     assert report["signature"] == sig
   |     ^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_witness.py:46:5
   |
44 |     )
45 |
46 |     assert result["exit"] == 0
   |     ^^^^^^
47 |     assert not sentinel.exists()
48 |     assert result["cmd"]
   |

S101 Use of `assert` detected
  --> engine/tests/test_witness.py:47:5
   |
46 |     assert result["exit"] == 0
47 |     assert not sentinel.exists()
   |     ^^^^^^
48 |     assert result["cmd"]
   |

S101 Use of `assert` detected
  --> engine/tests/test_witness.py:48:5
   |
46 |     assert result["exit"] == 0
47 |     assert not sentinel.exists()
48 |     assert result["cmd"]
   |     ^^^^^^
   |

S603 `subprocess` call: check for execution of untrusted input
  --> engine/tests/test_workflow_guards.py:13:12
   |
12 | def _run(cmd: list[str]) -> subprocess.CompletedProcess[str]:
13 |     return subprocess.run(cmd, cwd=REPO_ROOT, capture_output=True, text=True)
   |            ^^^^^^^^^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_workflow_guards.py:18:5
   |
16 | def test_verify_workflow_hygiene_passes() -> None:
17 |     p = _run(["python", "tools/verify_workflow_hygiene.py"])
18 |     assert p.returncode == 0, p.stdout + "\n" + p.stderr
   |     ^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_workflow_guards.py:23:5
   |
21 | def test_verify_action_pinning_passes() -> None:
22 |     p = _run(["python", "tools/verify_action_pinning.py"])
23 |     assert p.returncode == 0, p.stdout + "\n" + p.stderr
   |     ^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_workflow_guards.py:67:5
   |
65 |     )
66 |
67 |     assert p.returncode != 0
   |     ^^^^^^
68 |     assert "bad.yaml:t:step_0:actions/setup-python@v5" in p.stdout
   |

S101 Use of `assert` detected
  --> engine/tests/test_workflow_guards.py:68:5
   |
67 |     assert p.returncode != 0
68 |     assert "bad.yaml:t:step_0:actions/setup-python@v5" in p.stdout
   |     ^^^^^^
   |

S101 Use of `assert` detected
  --> engine/tests/test_workflow_guards.py:98:5
   |
96 |     )
97 |
98 |     assert p.returncode != 0
   |     ^^^^^^
99 |     assert "nested/bad.yaml:t:step_0:actions/setup-python@v5" in p.stdout
   |

S101 Use of `assert` detected
  --> engine/tests/test_workflow_guards.py:99:5
   |
98 |     assert p.returncode != 0
99 |     assert "nested/bad.yaml:t:step_0:actions/setup-python@v5" in p.stdout
   |     ^^^^^^
   |

S101 Use of `assert` detected
   --> engine/tests/test_workflow_guards.py:112:5
    |
110 |         str(missing),
111 |     ])
112 |     assert p.returncode == 2
    |     ^^^^^^
113 |     assert "FAIL: workflows directory validation failed" in p.stdout
    |

S101 Use of `assert` detected
   --> engine/tests/test_workflow_guards.py:113:5
    |
111 |     ])
112 |     assert p.returncode == 2
113 |     assert "FAIL: workflows directory validation failed" in p.stdout
    |     ^^^^^^
    |

S101 Use of `assert` detected
   --> engine/tests/test_workflow_guards.py:125:5
    |
123 |         str(workflows_dir),
124 |     ])
125 |     assert p.returncode == 2
    |     ^^^^^^
126 |     assert "no workflow files found" in p.stdout
    |

S101 Use of `assert` detected
   --> engine/tests/test_workflow_guards.py:126:5
    |
124 |     ])
125 |     assert p.returncode == 2
126 |     assert "no workflow files found" in p.stdout
    |     ^^^^^^
    |

S603 `subprocess` call: check for execution of untrusted input
   --> engine/tests/test_workflow_guards.py:131:9
    |
129 | def test_verify_action_pinning_autodetects_repo_root_from_subdir(tmp_path: Path) -> None:
130 |     nested_dir = REPO_ROOT / "tests"
131 |     p = subprocess.run(
    |         ^^^^^^^^^^^^^^
132 |         ["python", str(REPO_ROOT / "tools" / "verify_action_pinning.py")],
133 |         cwd=nested_dir,
    |

S607 Starting a process with a partial executable path
   --> engine/tests/test_workflow_guards.py:132:9
    |
130 |     nested_dir = REPO_ROOT / "tests"
131 |     p = subprocess.run(
132 |         ["python", str(REPO_ROOT / "tools" / "verify_action_pinning.py")],
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
133 |         cwd=nested_dir,
134 |         capture_output=True,
    |

S101 Use of `assert` detected
   --> engine/tests/test_workflow_guards.py:137:5
    |
135 |         text=True,
136 |     )
137 |     assert p.returncode == 0, p.stdout + "\n" + p.stderr
    |     ^^^^^^
    |

S101 Use of `assert` detected
   --> engine/tests/test_workflow_guards.py:148:5
    |
146 |         str(missing),
147 |     ])
148 |     assert p.returncode == 2
    |     ^^^^^^
149 |     assert "FAIL: workflow hygiene validation setup failed" in p.stdout
    |

S101 Use of `assert` detected
   --> engine/tests/test_workflow_guards.py:149:5
    |
147 |     ])
148 |     assert p.returncode == 2
149 |     assert "FAIL: workflow hygiene validation setup failed" in p.stdout
    |     ^^^^^^
    |

S101 Use of `assert` detected
   --> engine/tests/test_workflow_guards.py:161:5
    |
159 |         str(workflows_dir),
160 |     ])
161 |     assert p.returncode == 2
    |     ^^^^^^
162 |     assert "no workflow files found" in p.stdout
    |

S101 Use of `assert` detected
   --> engine/tests/test_workflow_guards.py:162:5
    |
160 |     ])
161 |     assert p.returncode == 2
162 |     assert "no workflow files found" in p.stdout
    |     ^^^^^^
    |

S603 `subprocess` call: check for execution of untrusted input
   --> engine/tests/test_workflow_guards.py:167:9
    |
165 | def test_verify_workflow_hygiene_autodetects_repo_root_from_subdir() -> None:
166 |     nested_dir = REPO_ROOT / "tests"
167 |     p = subprocess.run(
    |         ^^^^^^^^^^^^^^
168 |         ["python", str(REPO_ROOT / "tools" / "verify_workflow_hygiene.py")],
169 |         cwd=nested_dir,
    |

S607 Starting a process with a partial executable path
   --> engine/tests/test_workflow_guards.py:168:9
    |
166 |     nested_dir = REPO_ROOT / "tests"
167 |     p = subprocess.run(
168 |         ["python", str(REPO_ROOT / "tools" / "verify_workflow_hygiene.py")],
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
169 |         cwd=nested_dir,
170 |         capture_output=True,
    |

S101 Use of `assert` detected
   --> engine/tests/test_workflow_guards.py:173:5
    |
171 |         text=True,
172 |     )
173 |     assert p.returncode == 0, p.stdout + "\n" + p.stderr
    |     ^^^^^^
174 |
175 | def test_scorecard_workflow_has_fail_closed_sarif_contract() -> None:
    |

S101 Use of `assert` detected
   --> engine/tests/test_workflow_guards.py:178:9
    |
176 |     workflow_path = WORKFLOW_ROOT / ".github/workflows/scorecard.yml"
177 |     if not workflow_path.exists():
178 |         assert (WORKFLOW_ROOT / ".github/workflows/ci-supercheck.yml").exists()
    |         ^^^^^^
179 |         return
    |

S101 Use of `assert` detected
   --> engine/tests/test_workflow_guards.py:190:5
    |
188 |     }
189 |
190 |     assert "Run Scorecard" in named_steps
    |     ^^^^^^
191 |     scorecard_step = named_steps["Run Scorecard"]
192 |     assert scorecard_step.get("id") == "scorecard"
    |

S101 Use of `assert` detected
   --> engine/tests/test_workflow_guards.py:192:5
    |
190 |     assert "Run Scorecard" in named_steps
191 |     scorecard_step = named_steps["Run Scorecard"]
192 |     assert scorecard_step.get("id") == "scorecard"
    |     ^^^^^^
193 |     assert scorecard_step.get("continue-on-error") is True
194 |     assert (
    |

S101 Use of `assert` detected
   --> engine/tests/test_workflow_guards.py:193:5
    |
191 |     scorecard_step = named_steps["Run Scorecard"]
192 |     assert scorecard_step.get("id") == "scorecard"
193 |     assert scorecard_step.get("continue-on-error") is True
    |     ^^^^^^
194 |     assert (
195 |         scorecard_step.get("uses")
    |

S101 Use of `assert` detected
   --> engine/tests/test_workflow_guards.py:194:5
    |
192 |     assert scorecard_step.get("id") == "scorecard"
193 |     assert scorecard_step.get("continue-on-error") is True
194 |     assert (
    |     ^^^^^^
195 |         scorecard_step.get("uses")
196 |         == "ossf/scorecard-action@62b7fcb92755d80d6e46e3f6d2f13213dcd89f05"
    |

S101 Use of `assert` detected
   --> engine/tests/test_workflow_guards.py:198:5
    |
196 |         == "ossf/scorecard-action@62b7fcb92755d80d6e46e3f6d2f13213dcd89f05"
197 |     )
198 |     assert scorecard_step.get("with", {}).get("results_format") == "sarif"
    |     ^^^^^^
199 |     assert scorecard_step.get("with", {}).get("results_file") == (
200 |         "artifacts/security/scorecard-results.sarif"
    |

S101 Use of `assert` detected
   --> engine/tests/test_workflow_guards.py:199:5
    |
197 |     )
198 |     assert scorecard_step.get("with", {}).get("results_format") == "sarif"
199 |     assert scorecard_step.get("with", {}).get("results_file") == (
    |     ^^^^^^
200 |         "artifacts/security/scorecard-results.sarif"
201 |     )
    |

S101 Use of `assert` detected
   --> engine/tests/test_workflow_guards.py:203:5
    |
201 |     )
202 |
203 |     assert "Write deterministic Scorecard failure envelope" in named_steps
    |     ^^^^^^
204 |     failure_step = named_steps["Write deterministic Scorecard failure envelope"]
205 |     assert failure_step.get("if") == (
    |

S101 Use of `assert` detected
   --> engine/tests/test_workflow_guards.py:205:5
    |
203 |     assert "Write deterministic Scorecard failure envelope" in named_steps
204 |     failure_step = named_steps["Write deterministic Scorecard failure envelope"]
205 |     assert failure_step.get("if") == (
    |     ^^^^^^
206 |         "steps.scorecard.outcome != 'success' && !hashFiles('artifacts/security/scorecard-results.sarif')"
207 |     )
    |

S101 Use of `assert` detected
   --> engine/tests/test_workflow_guards.py:209:5
    |
207 |     )
208 |
209 |     assert "Upload Scorecard SARIF to code scanning" in named_steps
    |     ^^^^^^
210 |     upload_cs = named_steps["Upload Scorecard SARIF to code scanning"]
211 |     assert (
    |

S101 Use of `assert` detected
   --> engine/tests/test_workflow_guards.py:211:5
    |
209 |     assert "Upload Scorecard SARIF to code scanning" in named_steps
210 |     upload_cs = named_steps["Upload Scorecard SARIF to code scanning"]
211 |     assert (
    |     ^^^^^^
212 |         upload_cs.get("uses")
213 |         == "github/codeql-action/upload-sarif@b8f6507f3f5d3b9332f3d3e6585f6f8eecc65c0a"
    |

S101 Use of `assert` detected
   --> engine/tests/test_workflow_guards.py:215:5
    |
213 |         == "github/codeql-action/upload-sarif@b8f6507f3f5d3b9332f3d3e6585f6f8eecc65c0a"
214 |     )
215 |     assert upload_cs.get("with", {}).get("sarif_file") == (
    |     ^^^^^^
216 |         "artifacts/security/scorecard-results.sarif"
217 |     )
    |

S101 Use of `assert` detected
   --> engine/tests/test_workflow_guards.py:219:5
    |
217 |     )
218 |
219 |     assert "Upload Scorecard SARIF artifact" in named_steps
    |     ^^^^^^
220 |     upload_artifact = named_steps["Upload Scorecard SARIF artifact"]
221 |     assert upload_artifact.get("with", {}).get("if-no-files-found") == "error"
    |

S101 Use of `assert` detected
   --> engine/tests/test_workflow_guards.py:221:5
    |
219 |     assert "Upload Scorecard SARIF artifact" in named_steps
220 |     upload_artifact = named_steps["Upload Scorecard SARIF artifact"]
221 |     assert upload_artifact.get("with", {}).get("if-no-files-found") == "error"
    |     ^^^^^^
222 |     assert "artifacts/security/scorecard-results.sarif" in upload_artifact.get(
223 |         "with", {}
    |

S101 Use of `assert` detected
   --> engine/tests/test_workflow_guards.py:222:5
    |
220 |     upload_artifact = named_steps["Upload Scorecard SARIF artifact"]
221 |     assert upload_artifact.get("with", {}).get("if-no-files-found") == "error"
222 |     assert "artifacts/security/scorecard-results.sarif" in upload_artifact.get(
    |     ^^^^^^
223 |         "with", {}
224 |     ).get("path", "")
    |

S101 Use of `assert` detected
   --> engine/tests/test_workflow_guards.py:226:5
    |
224 |     ).get("path", "")
225 |
226 |     assert "Enforce Scorecard success" in named_steps
    |     ^^^^^^
    |

S603 `subprocess` call: check for execution of untrusted input
  --> engine/tools/agent/run_and_log.py:65:21
   |
63 |     timed_out = False
64 |     try:
65 |         completed = subprocess.run(
   |                     ^^^^^^^^^^^^^^
66 |             cmd,
67 |             cwd=str(cwd_path),
   |

S607 Starting a process with a partial executable path
  --> engine/tools/doctor.py:53:9
   |
51 |         )
52 |     proc = subprocess.run(
53 |         ["git", "--version"],
   |         ^^^^^^^^^^^^^^^^^^^^
54 |         check=False,
55 |         capture_output=True,
   |

S603 `subprocess` call: check for execution of untrusted input
  --> engine/tools/doctor.py:68:16
   |
67 | def _installer_check() -> CheckResult:
68 |     pip_proc = subprocess.run(
   |                ^^^^^^^^^^^^^^
69 |         [sys.executable, "-m", "pip", "--version"],
70 |         check=False,
   |

S603 `subprocess` call: check for execution of untrusted input
  --> engine/tools/doctor.py:89:19
   |
87 |         parts.append("uv=MISS")
88 |     else:
89 |         uv_proc = subprocess.run(
   |                   ^^^^^^^^^^^^^^
90 |             [uv_path, "--version"],
91 |             check=False,
   |

S603 `subprocess` call: check for execution of untrusted input
  --> engine/tools/feg_r8_verify.py:17:9
   |
15 | def run(cmd: list[str], cwd: Path | None = None) -> dict[str, Any]:
16 |     t0 = time.time()
17 |     p = subprocess.run(cmd, shell=False, text=True, capture_output=True, cwd=cwd)
   |         ^^^^^^^^^^^^^^
18 |     output = (p.stdout or "") + (p.stderr or "")
19 |     tail_lines = output.splitlines()[-20:]
   |

S603 `subprocess` call: check for execution of untrusted input
  --> engine/tools/feg_r8_verify.py:31:12
   |
30 | def git(cmd: list[str], cwd: Path | None = None) -> str:
31 |     proc = subprocess.run(
   |            ^^^^^^^^^^^^^^
32 |         ["git", *cmd],
33 |         check=True,
   |

S607 Starting a process with a partial executable path
  --> engine/tools/feg_r8_verify.py:32:9
   |
30 | def git(cmd: list[str], cwd: Path | None = None) -> str:
31 |     proc = subprocess.run(
32 |         ["git", *cmd],
   |         ^^^^^^^^^^^^^
33 |         check=True,
34 |         capture_output=True,
   |

S603 `subprocess` call: check for execution of untrusted input
   --> engine/tools/feg_r8_verify.py:102:9
    |
100 |     with tempfile.TemporaryDirectory(prefix="feg_r8_ablate_") as tmp:
101 |         wt = Path(tmp) / "wt"
102 |         subprocess.run(
    |         ^^^^^^^^^^^^^^
103 |             ["git", "worktree", "add", "--detach", str(wt), "HEAD"],
104 |             check=True,
    |

S607 Starting a process with a partial executable path
   --> engine/tools/feg_r8_verify.py:103:13
    |
101 |         wt = Path(tmp) / "wt"
102 |         subprocess.run(
103 |             ["git", "worktree", "add", "--detach", str(wt), "HEAD"],
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
104 |             check=True,
105 |             capture_output=True,
    |

S603 `subprocess` call: check for execution of untrusted input
   --> engine/tools/feg_r8_verify.py:112:21
    |
110 |                 file_path = wt / rel
111 |                 existed_in_base = (
112 |                     subprocess.run(
    |                     ^^^^^^^^^^^^^^
113 |                         ["git", "cat-file", "-e", f"{base_sha}:{rel}"],
114 |                         cwd=wt,
    |

S607 Starting a process with a partial executable path
   --> engine/tools/feg_r8_verify.py:113:25
    |
111 |                 existed_in_base = (
112 |                     subprocess.run(
113 |                         ["git", "cat-file", "-e", f"{base_sha}:{rel}"],
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
114 |                         cwd=wt,
115 |                         check=False,
    |

S603 `subprocess` call: check for execution of untrusted input
   --> engine/tools/feg_r8_verify.py:123:21
    |
122 |                 if existed_in_base:
123 |                     subprocess.run(
    |                     ^^^^^^^^^^^^^^
124 |                         ["git", "checkout", base_sha, "--", rel],
125 |                         cwd=wt,
    |

S607 Starting a process with a partial executable path
   --> engine/tools/feg_r8_verify.py:124:25
    |
122 |                 if existed_in_base:
123 |                     subprocess.run(
124 |                         ["git", "checkout", base_sha, "--", rel],
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
125 |                         cwd=wt,
126 |                         check=True,
    |

S603 `subprocess` call: check for execution of untrusted input
   --> engine/tools/feg_r8_verify.py:131:21
    |
129 |                     )
130 |                 elif file_path.exists():
131 |                     subprocess.run(
    |                     ^^^^^^^^^^^^^^
132 |                         ["git", "rm", "-f", "--", rel],
133 |                         cwd=wt,
    |

S607 Starting a process with a partial executable path
   --> engine/tools/feg_r8_verify.py:132:25
    |
130 |                 elif file_path.exists():
131 |                     subprocess.run(
132 |                         ["git", "rm", "-f", "--", rel],
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
133 |                         cwd=wt,
134 |                         check=True,
    |

S607 Starting a process with a partial executable path
   --> engine/tools/feg_r8_verify.py:155:21
    |
154 |                 subprocess.run(
155 |                     ["git", "reset", "--hard", "HEAD"],
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
156 |                     cwd=wt,
157 |                     check=True,
    |

S607 Starting a process with a partial executable path
   --> engine/tools/feg_r8_verify.py:162:21
    |
160 |                 )
161 |                 subprocess.run(
162 |                     ["git", "clean", "-ffd"],
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^
163 |                     cwd=wt,
164 |                     check=True,
    |

S603 `subprocess` call: check for execution of untrusted input
   --> engine/tools/feg_r8_verify.py:169:13
    |
167 |                 )
168 |         finally:
169 |             subprocess.run(
    |             ^^^^^^^^^^^^^^
170 |                 ["git", "worktree", "remove", "--force", str(wt)],
171 |                 check=True,
    |

S607 Starting a process with a partial executable path
   --> engine/tools/feg_r8_verify.py:170:17
    |
168 |         finally:
169 |             subprocess.run(
170 |                 ["git", "worktree", "remove", "--force", str(wt)],
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
171 |                 check=True,
172 |                 capture_output=True,
    |

S603 `subprocess` call: check for execution of untrusted input
  --> engine/tools/generate_titan9_proof.py:22:12
   |
21 | def _run(repo_root: Path, command: list[str]) -> subprocess.CompletedProcess[str]:
22 |     return subprocess.run(
   |            ^^^^^^^^^^^^^^
23 |         command,
24 |         cwd=repo_root,
   |

S603 `subprocess` call: check for execution of untrusted input
  --> engine/tools/nongit_runner.py:59:16
   |
57 |             pytest_cmd = pytest_cmd[1:]
58 |
59 |         proc = subprocess.run(
   |                ^^^^^^^^^^^^^^
60 |             pytest_cmd,
61 |             cwd=copied_repo,
   |

S603 `subprocess` call: check for execution of untrusted input
   --> engine/tools/pip_audit_gate.py:203:12
    |
201 |         cmd.extend(["--ignore-vuln", vuln_id])
202 |
203 |     proc = subprocess.run(cmd, check=False, capture_output=True, text=True)
    |            ^^^^^^^^^^^^^^
204 |     if proc.returncode != 0:
205 |         combined = (proc.stdout or "") + (proc.stderr or "")
    |

S603 `subprocess` call: check for execution of untrusted input
  --> engine/tools/run_gate.py:32:13
   |
31 | def _repo_root_from_git(cwd: Path) -> Path | None:
32 |     probe = subprocess.run(
   |             ^^^^^^^^^^^^^^
33 |         ["git", "-C", str(cwd), "rev-parse", "--show-toplevel"],
34 |         capture_output=True,
   |

S607 Starting a process with a partial executable path
  --> engine/tools/run_gate.py:33:9
   |
31 | def _repo_root_from_git(cwd: Path) -> Path | None:
32 |     probe = subprocess.run(
33 |         ["git", "-C", str(cwd), "rev-parse", "--show-toplevel"],
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
34 |         capture_output=True,
35 |         text=True,
   |

S603 `subprocess` call: check for execution of untrusted input
  --> engine/tools/run_gate.py:90:14
   |
88 |     start_ts = _iso_now()
89 |     start = time.monotonic()
90 |     result = subprocess.run(cmd, cwd=cwd, capture_output=True, text=True, check=False)
   |              ^^^^^^^^^^^^^^
91 |     duration = round(time.monotonic() - start, 3)
92 |     end_ts = _iso_now()
   |

S607 Starting a process with a partial executable path
  --> engine/tools/secret_scan_gate.py:43:9
   |
41 | def _tracked_files(repo_root: Path) -> list[Path]:
42 |     p = subprocess.run(
43 |         ["git", "ls-files"], cwd=repo_root, capture_output=True, text=True, check=False
   |         ^^^^^^^^^^^^^^^^^^^
44 |     )
45 |     if p.returncode != 0:
   |

S101 Use of `assert` detected
  --> engine/tools/verify_action_pinning.py:96:5
   |
94 |             print(item)
95 |         return 2
96 |     assert root is not None
   |     ^^^^^^
97 |
98 |     violations: list[str] = []
   |

S603 `subprocess` call: check for execution of untrusted input
  --> engine/tools/witness.py:23:9
   |
22 | def _run(cmd: list[str]) -> dict[str, Any]:
23 |     p = subprocess.run(cmd, shell=False, capture_output=True, text=True)
   |         ^^^^^^^^^^^^^^
24 |     output = (p.stdout or "") + (p.stderr or "")
25 |     tail = "\n".join(output.splitlines()[-20:])
   |

S110 `try`-`except`-`pass` detected, consider logging the exception
   --> evidence/release_wrapper/promoted_artifacts_2026-02-26/engine/scripts/check_prod_spec_gates.py:226:9
    |
224 |           try:
225 |               pbs.append((pb_file, load_json(pb_file)))
226 | /         except Exception:
227 | |             pass
    | |________________^
228 |       # Sort by timestamp
229 |       pbs.sort(key=lambda x: x[1].get("timestamp", ""))
    |

S110 `try`-`except`-`pass` detected, consider logging the exception
   --> evidence/release_wrapper/promoted_bundle_2026-02-26/engine/scripts/check_prod_spec_gates.py:226:9
    |
224 |           try:
225 |               pbs.append((pb_file, load_json(pb_file)))
226 | /         except Exception:
227 | |             pass
    | |________________^
228 |       # Sort by timestamp
229 |       pbs.sort(key=lambda x: x[1].get("timestamp", ""))
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/engine.py:475:9
    |
474 |         proof = self._state.proof
475 |         assert proof is not None
    |         ^^^^^^
476 |
477 |         h = self._config.checkpoint_store.save_bundle(proof)
    |

S101 Use of `assert` detected
  --> sources/legacy/E-legacy_snapshot/tests.py:44:9
   |
42 | class TestCheckStatus:
43 |     def test_green(self):
44 |         assert CheckStatus.SUCCESS.is_green
   |         ^^^^^^
45 |         assert not CheckStatus.FAILURE.is_green
46 |         assert not CheckStatus.PENDING.is_green
   |

S101 Use of `assert` detected
  --> sources/legacy/E-legacy_snapshot/tests.py:45:9
   |
43 |     def test_green(self):
44 |         assert CheckStatus.SUCCESS.is_green
45 |         assert not CheckStatus.FAILURE.is_green
   |         ^^^^^^
46 |         assert not CheckStatus.PENDING.is_green
   |

S101 Use of `assert` detected
  --> sources/legacy/E-legacy_snapshot/tests.py:46:9
   |
44 |         assert CheckStatus.SUCCESS.is_green
45 |         assert not CheckStatus.FAILURE.is_green
46 |         assert not CheckStatus.PENDING.is_green
   |         ^^^^^^
47 |
48 |     def test_terminal(self):
   |

S101 Use of `assert` detected
  --> sources/legacy/E-legacy_snapshot/tests.py:49:9
   |
48 |     def test_terminal(self):
49 |         assert CheckStatus.SUCCESS.is_terminal
   |         ^^^^^^
50 |         assert CheckStatus.FAILURE.is_terminal
51 |         assert not CheckStatus.PENDING.is_terminal
   |

S101 Use of `assert` detected
  --> sources/legacy/E-legacy_snapshot/tests.py:50:9
   |
48 |     def test_terminal(self):
49 |         assert CheckStatus.SUCCESS.is_terminal
50 |         assert CheckStatus.FAILURE.is_terminal
   |         ^^^^^^
51 |         assert not CheckStatus.PENDING.is_terminal
   |

S101 Use of `assert` detected
  --> sources/legacy/E-legacy_snapshot/tests.py:51:9
   |
49 |         assert CheckStatus.SUCCESS.is_terminal
50 |         assert CheckStatus.FAILURE.is_terminal
51 |         assert not CheckStatus.PENDING.is_terminal
   |         ^^^^^^
   |

S101 Use of `assert` detected
  --> sources/legacy/E-legacy_snapshot/tests.py:57:9
   |
55 |     def test_valid_hash(self):
56 |         ref = ArtifactRef(path="a.txt", sha256="a" * 64)
57 |         assert ref.sha256 == "a" * 64
   |         ^^^^^^
58 |
59 |     def test_invalid_hash_rejects(self):
   |

S101 Use of `assert` detected
  --> sources/legacy/E-legacy_snapshot/tests.py:65:9
   |
63 |     def test_empty_hash_ok(self):
64 |         ref = ArtifactRef(path="a.txt", sha256="")
65 |         assert ref.sha256 == ""
   |         ^^^^^^
66 |
67 |     def test_from_file(self, tmp_path):
   |

S101 Use of `assert` detected
  --> sources/legacy/E-legacy_snapshot/tests.py:71:9
   |
69 |         f.write_bytes(b"hello world")
70 |         ref = ArtifactRef.from_file(f)
71 |         assert ref.sha256
   |         ^^^^^^
72 |         assert len(ref.sha256) == 64
   |

S101 Use of `assert` detected
  --> sources/legacy/E-legacy_snapshot/tests.py:72:9
   |
70 |         ref = ArtifactRef.from_file(f)
71 |         assert ref.sha256
72 |         assert len(ref.sha256) == 64
   |         ^^^^^^
   |

S101 Use of `assert` detected
  --> sources/legacy/E-legacy_snapshot/tests.py:81:9
   |
79 |             done_when=["All checks green"],
80 |         )
81 |         assert ts.goal == "Fix CI"
   |         ^^^^^^
82 |
83 |     def test_empty_goal_fails(self):
   |

S101 Use of `assert` detected
  --> sources/legacy/E-legacy_snapshot/tests.py:93:9
   |
91 |     def test_auto_detect_required(self):
92 |         ts = TargetState(goal="Fix", done_when=["Checks pass"])
93 |         assert ts.required_checks == "auto-detect from PR"
   |         ^^^^^^
   |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:99:9
    |
 97 |     def test_defaults(self):
 98 |         c = Constraints()
 99 |         assert c.touch_allowlist == ["*"]
    |         ^^^^^^
100 |         assert c.diff_budget.max_files == 20
101 |         assert c.refactor_policy == RefactorPolicy.NO_REFACTOR
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:100:9
    |
 98 |         c = Constraints()
 99 |         assert c.touch_allowlist == ["*"]
100 |         assert c.diff_budget.max_files == 20
    |         ^^^^^^
101 |         assert c.refactor_policy == RefactorPolicy.NO_REFACTOR
102 |         assert c.security_policy.no_disable_security_checks is True
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:101:9
    |
 99 |         assert c.touch_allowlist == ["*"]
100 |         assert c.diff_budget.max_files == 20
101 |         assert c.refactor_policy == RefactorPolicy.NO_REFACTOR
    |         ^^^^^^
102 |         assert c.security_policy.no_disable_security_checks is True
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:102:9
    |
100 |         assert c.diff_budget.max_files == 20
101 |         assert c.refactor_policy == RefactorPolicy.NO_REFACTOR
102 |         assert c.security_policy.no_disable_security_checks is True
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:112:9
    |
110 |             done_when="lint check passes",
111 |         )
112 |         assert fp.severity == 0
    |         ^^^^^^
113 |
114 |     def test_insufficient_signal(self):
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:141:9
    |
139 |     def test_all_green(self):
140 |         b = self._make_bundle(green=True)
141 |         assert b.all_green
    |         ^^^^^^
142 |
143 |     def test_not_green(self):
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:145:9
    |
143 |     def test_not_green(self):
144 |         b = self._make_bundle(green=False)
145 |         assert not b.all_green
    |         ^^^^^^
146 |
147 |     def test_integrity_hash_deterministic(self):
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:151:9
    |
149 |         h1 = b.integrity_hash()
150 |         h2 = b.integrity_hash()
151 |         assert h1 == h2
    |         ^^^^^^
152 |         assert len(h1) == 64
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:152:9
    |
150 |         h2 = b.integrity_hash()
151 |         assert h1 == h2
152 |         assert len(h1) == 64
    |         ^^^^^^
153 |
154 |     def test_duration(self):
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:156:9
    |
154 |     def test_duration(self):
155 |         b = self._make_bundle()
156 |         assert b.time.duration_seconds == 300.0
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:175:9
    |
173 |         )
174 |         state.record("TEST_EVENT", key="val")
175 |         assert len(state.history) == 1
    |         ^^^^^^
176 |         assert state.history[0]["event"] == "TEST_EVENT"
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:176:9
    |
174 |         state.record("TEST_EVENT", key="val")
175 |         assert len(state.history) == 1
176 |         assert state.history[0]["event"] == "TEST_EVENT"
    |         ^^^^^^
177 |
178 |     def test_halt(self):
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:184:9
    |
182 |         )
183 |         state.halt("budget exceeded")
184 |         assert state.halted
    |         ^^^^^^
185 |         assert state.phase == Phase.HALTED
186 |         assert "budget" in state.halt_reason
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:185:9
    |
183 |         state.halt("budget exceeded")
184 |         assert state.halted
185 |         assert state.phase == Phase.HALTED
    |         ^^^^^^
186 |         assert "budget" in state.halt_reason
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:186:9
    |
184 |         assert state.halted
185 |         assert state.phase == Phase.HALTED
186 |         assert "budget" in state.halt_reason
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:200:9
    |
198 |     def test_wildcard_allows_all(self):
199 |         e = self._enforcer()
200 |         assert e.check_path("any/path/file.py") is None
    |         ^^^^^^
201 |
202 |     def test_denylist_blocks(self):
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:205:9
    |
203 |         e = self._enforcer(touch_denylist=["secrets/**"])
204 |         v = e.check_path("secrets/key.pem")
205 |         assert v is not None
    |         ^^^^^^
206 |         assert v.rule == "touch_denylist"
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:206:9
    |
204 |         v = e.check_path("secrets/key.pem")
205 |         assert v is not None
206 |         assert v.rule == "touch_denylist"
    |         ^^^^^^
207 |
208 |     def test_allowlist_restricts(self):
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:211:9
    |
209 |         e = self._enforcer(touch_allowlist=["src/*"])
210 |         v = e.check_path("tests/test.py")
211 |         assert v is not None
    |         ^^^^^^
212 |         assert v.rule == "touch_allowlist"
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:212:9
    |
210 |         v = e.check_path("tests/test.py")
211 |         assert v is not None
212 |         assert v.rule == "touch_allowlist"
    |         ^^^^^^
213 |
214 |     def test_diff_budget_ok(self):
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:217:9
    |
215 |         e = self._enforcer()
216 |         vs = e.check_diff(DiffSummary(files_changed=5, loc_delta=100))
217 |         assert vs == []
    |         ^^^^^^
218 |
219 |     def test_diff_budget_exceeded(self):
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:224:9
    |
222 |         )
223 |         vs = e.check_diff(DiffSummary(files_changed=5, loc_delta=100))
224 |         assert len(vs) == 2
    |         ^^^^^^
225 |
226 |     def test_refactor_blocked(self):
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:229:9
    |
227 |         e = self._enforcer(refactor_policy=RefactorPolicy.NO_REFACTOR)
228 |         v = e.check_refactor(has_refactor=True)
229 |         assert v is not None
    |         ^^^^^^
230 |
231 |     def test_refactor_allowed(self):
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:234:9
    |
232 |         e = self._enforcer(refactor_policy=RefactorPolicy.ALLOWED)
233 |         v = e.check_refactor(has_refactor=True)
234 |         assert v is None
    |         ^^^^^^
235 |
236 |     def test_security_violations(self):
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:242:9
    |
240 |             unpinned_actions=["actions/checkout@main"],
241 |         )
242 |         assert len(vs) == 2
    |         ^^^^^^
243 |
244 |     def test_full_sweep(self):
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:253:9
    |
251 |             diff=DiffSummary(files_changed=5, loc_delta=100),
252 |         )
253 |         assert len(vs) >= 3  # deny + files + loc
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:273:9
    |
271 |             t_green=datetime.now(timezone.utc),
272 |         )
273 |         assert bundle.all_green
    |         ^^^^^^
274 |
275 |     def test_validate_incomplete(self):
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:284:9
    |
282 |         )
283 |         issues = ProofAssembler.validate(bundle)
284 |         assert len(issues) >= 3  # missing pr, sha, checks, t_green
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:306:9
    |
304 |         bundle = self._make_bundle()
305 |         h = store.save_bundle(bundle)
306 |         assert len(h) == 64
    |         ^^^^^^
307 |
308 |         loaded = store.load_bundle(h[:8])
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:309:9
    |
308 |         loaded = store.load_bundle(h[:8])
309 |         assert loaded is not None
    |         ^^^^^^
310 |         assert loaded.commit_sha == "abc1234"
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:310:9
    |
308 |         loaded = store.load_bundle(h[:8])
309 |         assert loaded is not None
310 |         assert loaded.commit_sha == "abc1234"
    |         ^^^^^^
311 |
312 |     def test_idempotent_save(self, tmp_path):
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:317:9
    |
315 |         h1 = store.save_bundle(bundle)
316 |         h2 = store.save_bundle(bundle)
317 |         assert h1 == h2
    |         ^^^^^^
318 |
319 |     def test_ledger(self, tmp_path):
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:324:9
    |
322 |         store.save_bundle(bundle)
323 |         entries = store.list_bundles()
324 |         assert len(entries) == 1
    |         ^^^^^^
325 |
326 |     def test_state_snapshot(self, tmp_path):
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:334:9
    |
332 |         store.save_state(state, "test_snap")
333 |         loaded = store.load_state("test_snap")
334 |         assert loaded is not None
    |         ^^^^^^
335 |         assert loaded.target.goal == "test"
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:335:9
    |
333 |         loaded = store.load_state("test_snap")
334 |         assert loaded is not None
335 |         assert loaded.target.goal == "test"
    |         ^^^^^^
336 |
337 |     def test_artifact_verify(self, tmp_path):
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:342:9
    |
340 |         f.write_bytes(b"test data")
341 |         ref = ArtifactRef.from_file(f)
342 |         assert store.verify_artifact(ref)
    |         ^^^^^^
343 |
344 |         # Tamper
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:346:9
    |
344 |         # Tamper
345 |         f.write_bytes(b"tampered")
346 |         assert not store.verify_artifact(ref)
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:357:9
    |
355 |     def test_kpd_zero_when_no_data(self):
356 |         m = LoopMetrics()
357 |         assert m.kpd == 0.0
    |         ^^^^^^
358 |
359 |     def test_kpd_calculation(self):
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:371:9
    |
369 |         # penalty = 1 + 100/500 + 2/10 = 1 + 0.2 + 0.2 = 1.4
370 |         # kpd = 5 / 1.4  3.5714
371 |         assert 3.5 < m.kpd < 3.6
    |         ^^^^^^
372 |
373 |     def test_rework_ratio(self):
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:377:9
    |
375 |         m.total_iterations = 10
376 |         m.rework_iterations = 3
377 |         assert m.r_rework == 0.3
    |         ^^^^^^
378 |
379 |     def test_record_iteration(self):
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:383:9
    |
381 |         m.record_iteration(closed=2, new_failures=False)
382 |         m.record_iteration(closed=1, new_failures=True)
383 |         assert m.total_iterations == 2
    |         ^^^^^^
384 |         assert m.closures == 3
385 |         assert m.rework_iterations == 1
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:384:9
    |
382 |         m.record_iteration(closed=1, new_failures=True)
383 |         assert m.total_iterations == 2
384 |         assert m.closures == 3
    |         ^^^^^^
385 |         assert m.rework_iterations == 1
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:385:9
    |
383 |         assert m.total_iterations == 2
384 |         assert m.closures == 3
385 |         assert m.rework_iterations == 1
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:400:9
    |
399 |         ledger.record("hash123", m, pr="test")
400 |         assert ledger.total_closures == 3
    |         ^^^^^^
401 |         assert ledger.avg_kpd > 0
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:401:9
    |
399 |         ledger.record("hash123", m, pr="test")
400 |         assert ledger.total_closures == 3
401 |         assert ledger.avg_kpd > 0
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:422:9
    |
420 |         scout = Scout()
421 |         packets = scout.execute(state, all_checks=checks)
422 |         assert len(packets) == 2
    |         ^^^^^^
423 |         assert packets[0].check_name in ("lint", "build")
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:423:9
    |
421 |         packets = scout.execute(state, all_checks=checks)
422 |         assert len(packets) == 2
423 |         assert packets[0].check_name in ("lint", "build")
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:442:9
    |
440 |         planner = Planner()
441 |         plan = planner.execute(state, packets=packets)
442 |         assert len(plan) == 1
    |         ^^^^^^
443 |         assert plan[0]["packet_id"] == "FP-001"
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:443:9
    |
441 |         plan = planner.execute(state, packets=packets)
442 |         assert len(plan) == 1
443 |         assert plan[0]["packet_id"] == "FP-001"
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:462:9
    |
460 |             touched_files=["src/main.py"],
461 |         )
462 |         assert verdict == AuditVerdict.OK
    |         ^^^^^^
463 |         assert len(findings) == 0
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:463:9
    |
461 |         )
462 |         assert verdict == AuditVerdict.OK
463 |         assert len(findings) == 0
    |         ^^^^^^
464 |
465 |     def test_failing_check_needs_change(self):
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:480:9
    |
478 |             touched_files=[],
479 |         )
480 |         assert verdict == AuditVerdict.NEEDS_CHANGE
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:516:9
    |
514 |         )
515 |
516 |         assert decision.action == GovernorDecision.MERGE
    |         ^^^^^^
517 |
518 |     def test_failing_goes_next(self, tmp_path):
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:533:9
    |
531 |         )
532 |
533 |         assert decision.action == GovernorDecision.NEXT
    |         ^^^^^^
534 |
535 |     def test_max_iterations_halt(self, tmp_path):
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:563:9
    |
561 |         )
562 |
563 |         assert decision.action == GovernorDecision.HALT
    |         ^^^^^^
564 |
565 |     def test_can_stop(self, tmp_path):
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:580:9
    |
578 |         )
579 |
580 |         assert loop.can_stop()
    |         ^^^^^^
581 |
582 |     def test_checkpoint_and_stop(self, tmp_path):
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:598:9
    |
597 |         result = loop.checkpoint_and_stop()
598 |         assert result["stopped"]
    |         ^^^^^^
599 |         assert result["proof_hash"]
600 |         assert result["metrics"]["kpd"] >= 0
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:599:9
    |
597 |         result = loop.checkpoint_and_stop()
598 |         assert result["stopped"]
599 |         assert result["proof_hash"]
    |         ^^^^^^
600 |         assert result["metrics"]["kpd"] >= 0
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:600:9
    |
598 |         assert result["stopped"]
599 |         assert result["proof_hash"]
600 |         assert result["metrics"]["kpd"] >= 0
    |         ^^^^^^
601 |
602 |     def test_governor_fn_override(self, tmp_path):
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:623:9
    |
621 |         )
622 |
623 |         assert decision.action == GovernorDecision.HOLD
    |         ^^^^^^
624 |         assert decision.reason == "Manual review"
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:624:9
    |
623 |         assert decision.action == GovernorDecision.HOLD
624 |         assert decision.reason == "Manual review"
    |         ^^^^^^
625 |
626 |     def test_constraint_halt_in_spec(self, tmp_path):
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:653:9
    |
651 |         enforcer = ConstraintEnforcer(constraints)
652 |         violations = enforcer.check_paths(spec.scope_files)
653 |         assert len(violations) > 0
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:664:9
    |
662 |     def test_parse_url(self):
663 |         ref = PRRef.parse("https://github.com/owner/repo/pull/42")
664 |         assert ref.owner == "owner"
    |         ^^^^^^
665 |         assert ref.repo == "repo"
666 |         assert ref.number == 42
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:665:9
    |
663 |         ref = PRRef.parse("https://github.com/owner/repo/pull/42")
664 |         assert ref.owner == "owner"
665 |         assert ref.repo == "repo"
    |         ^^^^^^
666 |         assert ref.number == 42
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:666:9
    |
664 |         assert ref.owner == "owner"
665 |         assert ref.repo == "repo"
666 |         assert ref.number == 42
    |         ^^^^^^
667 |
668 |     def test_parse_shorthand(self):
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:670:9
    |
668 |     def test_parse_shorthand(self):
669 |         ref = PRRef.parse("owner/repo#42")
670 |         assert ref.owner == "owner"
    |         ^^^^^^
671 |         assert ref.number == 42
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:671:9
    |
669 |         ref = PRRef.parse("owner/repo#42")
670 |         assert ref.owner == "owner"
671 |         assert ref.number == 42
    |         ^^^^^^
672 |
673 |     def test_parse_invalid(self):
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:679:9
    |
677 |     def test_html_url(self):
678 |         ref = PRRef(owner="o", repo="r", number=1)
679 |         assert ref.html_url == "https://github.com/o/r/pull/1"
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:685:9
    |
683 |     def test_run_success(self):
684 |         code, output = LocalGate.run("echo hello")
685 |         assert code == 0
    |         ^^^^^^
686 |         assert "hello" in output
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:686:9
    |
684 |         code, output = LocalGate.run("echo hello")
685 |         assert code == 0
686 |         assert "hello" in output
    |         ^^^^^^
687 |
688 |     def test_run_failure(self):
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:690:9
    |
688 |     def test_run_failure(self):
689 |         code, _ = LocalGate.run("false")
690 |         assert code != 0
    |         ^^^^^^
691 |
692 |     def test_run_timeout(self):
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:694:9
    |
692 |     def test_run_timeout(self):
693 |         code, output = LocalGate.run("sleep 10", timeout=0.1)
694 |         assert code == 124
    |         ^^^^^^
695 |         assert "TIMEOUT" in output
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:695:9
    |
693 |         code, output = LocalGate.run("sleep 10", timeout=0.1)
694 |         assert code == 124
695 |         assert "TIMEOUT" in output
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:733:9
    |
732 |         # Should merge
733 |         assert decision.action == GovernorDecision.MERGE
    |         ^^^^^^
734 |
735 |         # Proof should exist
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:736:9
    |
735 |         # Proof should exist
736 |         assert loop.state.proof is not None
    |         ^^^^^^
737 |         assert loop.state.proof.all_green
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:737:9
    |
735 |         # Proof should exist
736 |         assert loop.state.proof is not None
737 |         assert loop.state.proof.all_green
    |         ^^^^^^
738 |
739 |         # Can stop
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:740:9
    |
739 |         # Can stop
740 |         assert loop.can_stop()
    |         ^^^^^^
741 |
742 |         # Checkpoint
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:744:9
    |
742 |         # Checkpoint
743 |         result = loop.checkpoint_and_stop()
744 |         assert result["stopped"]
    |         ^^^^^^
745 |
746 |         # Verify ledger
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:748:9
    |
746 |         # Verify ledger
747 |         entries = store.list_bundles()
748 |         assert len(entries) >= 1
    |         ^^^^^^
749 |
750 |         # Verify state snapshot
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:752:9
    |
750 |         # Verify state snapshot
751 |         states = store.list_states()
752 |         assert "final" in states
    |         ^^^^^^
753 |
754 |     def test_fix_path(self, tmp_path):
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:776:9
    |
774 |             touched_files=["a.py"],
775 |         )
776 |         assert d1.action == GovernorDecision.NEXT
    |         ^^^^^^
777 |
778 |         # Iteration 2: green
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:788:9
    |
786 |             touched_files=["a.py"],
787 |         )
788 |         assert d2.action == GovernorDecision.MERGE
    |         ^^^^^^
789 |         assert loop.state.iteration == 2
    |

S101 Use of `assert` detected
   --> sources/legacy/E-legacy_snapshot/tests.py:789:9
    |
787 |         )
788 |         assert d2.action == GovernorDecision.MERGE
789 |         assert loop.state.iteration == 2
    |         ^^^^^^
    |

S602 `subprocess` call with `shell=True` identified, security issue
   --> sources/legacy/E-legacy_snapshot/truth_plane.py:292:22
    |
291 |         try:
292 |             result = subprocess.run(
    |                      ^^^^^^^^^^^^^^
293 |                 cmd,
294 |                 shell=True,
    |

S311 Standard pseudo-random generators are not suitable for cryptographic purposes
   --> tools/dao-arbiter/dao_lifebook/_retry.py:129:55
    |
127 |                 cfg.max_delay,
128 |             )
129 |             jitter = delay * cfg.jitter_factor * (2 * random.random() - 1)
    |                                                       ^^^^^^^^^^^^^^^
130 |             actual_delay = max(0, delay + jitter)
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/engine.py:460:9
    |
459 |         proof = self._state.proof
460 |         assert proof is not None
    |         ^^^^^^
461 |
462 |         result = self._config.checkpoint_store.save_bundle(proof)
    |

S101 Use of `assert` detected
  --> tools/dao-arbiter/dao_lifebook/tests.py:38:9
   |
36 |     def test_ok_is_ok(self):
37 |         r = Ok(42)
38 |         assert r.is_ok()
   |         ^^^^^^
39 |         assert not r.is_err()
40 |         assert r.unwrap() == 42
   |

S101 Use of `assert` detected
  --> tools/dao-arbiter/dao_lifebook/tests.py:39:9
   |
37 |         r = Ok(42)
38 |         assert r.is_ok()
39 |         assert not r.is_err()
   |         ^^^^^^
40 |         assert r.unwrap() == 42
   |

S101 Use of `assert` detected
  --> tools/dao-arbiter/dao_lifebook/tests.py:40:9
   |
38 |         assert r.is_ok()
39 |         assert not r.is_err()
40 |         assert r.unwrap() == 42
   |         ^^^^^^
41 |
42 |     def test_err_is_err(self):
   |

S101 Use of `assert` detected
  --> tools/dao-arbiter/dao_lifebook/tests.py:44:9
   |
42 |     def test_err_is_err(self):
43 |         r = Err("fail")
44 |         assert r.is_err()
   |         ^^^^^^
45 |         assert not r.is_ok()
46 |         assert r.unwrap_err() == "fail"
   |

S101 Use of `assert` detected
  --> tools/dao-arbiter/dao_lifebook/tests.py:45:9
   |
43 |         r = Err("fail")
44 |         assert r.is_err()
45 |         assert not r.is_ok()
   |         ^^^^^^
46 |         assert r.unwrap_err() == "fail"
   |

S101 Use of `assert` detected
  --> tools/dao-arbiter/dao_lifebook/tests.py:46:9
   |
44 |         assert r.is_err()
45 |         assert not r.is_ok()
46 |         assert r.unwrap_err() == "fail"
   |         ^^^^^^
47 |
48 |     def test_ok_unwrap_err_raises(self):
   |

S101 Use of `assert` detected
  --> tools/dao-arbiter/dao_lifebook/tests.py:58:9
   |
56 |     def test_ok_map(self):
57 |         r = Ok(5).map(lambda x: x * 2)
58 |         assert r.unwrap() == 10
   |         ^^^^^^
59 |
60 |     def test_err_map_propagates(self):
   |

S101 Use of `assert` detected
  --> tools/dao-arbiter/dao_lifebook/tests.py:62:9
   |
60 |     def test_err_map_propagates(self):
61 |         r = Err("fail").map(lambda x: x * 2)
62 |         assert r.is_err()
   |         ^^^^^^
63 |         assert r.unwrap_err() == "fail"
   |

S101 Use of `assert` detected
  --> tools/dao-arbiter/dao_lifebook/tests.py:63:9
   |
61 |         r = Err("fail").map(lambda x: x * 2)
62 |         assert r.is_err()
63 |         assert r.unwrap_err() == "fail"
   |         ^^^^^^
64 |
65 |     def test_dao_error_str(self):
   |

S101 Use of `assert` detected
  --> tools/dao-arbiter/dao_lifebook/tests.py:67:9
   |
65 |     def test_dao_error_str(self):
66 |         e = DAOError(code="TEST", message="bad thing")
67 |         assert "[TEST]" in str(e)
   |         ^^^^^^
68 |         assert "bad thing" in str(e)
   |

S101 Use of `assert` detected
  --> tools/dao-arbiter/dao_lifebook/tests.py:68:9
   |
66 |         e = DAOError(code="TEST", message="bad thing")
67 |         assert "[TEST]" in str(e)
68 |         assert "bad thing" in str(e)
   |         ^^^^^^
   |

S101 Use of `assert` detected
  --> tools/dao-arbiter/dao_lifebook/tests.py:87:9
   |
85 | class TestCheckStatus:
86 |     def test_green(self):
87 |         assert CheckStatus.SUCCESS.is_green
   |         ^^^^^^
88 |         assert not CheckStatus.FAILURE.is_green
89 |         assert not CheckStatus.PENDING.is_green
   |

S101 Use of `assert` detected
  --> tools/dao-arbiter/dao_lifebook/tests.py:88:9
   |
86 |     def test_green(self):
87 |         assert CheckStatus.SUCCESS.is_green
88 |         assert not CheckStatus.FAILURE.is_green
   |         ^^^^^^
89 |         assert not CheckStatus.PENDING.is_green
   |

S101 Use of `assert` detected
  --> tools/dao-arbiter/dao_lifebook/tests.py:89:9
   |
87 |         assert CheckStatus.SUCCESS.is_green
88 |         assert not CheckStatus.FAILURE.is_green
89 |         assert not CheckStatus.PENDING.is_green
   |         ^^^^^^
90 |
91 |     def test_terminal(self):
   |

S101 Use of `assert` detected
  --> tools/dao-arbiter/dao_lifebook/tests.py:92:9
   |
91 |     def test_terminal(self):
92 |         assert CheckStatus.SUCCESS.is_terminal
   |         ^^^^^^
93 |         assert CheckStatus.FAILURE.is_terminal
94 |         assert not CheckStatus.PENDING.is_terminal
   |

S101 Use of `assert` detected
  --> tools/dao-arbiter/dao_lifebook/tests.py:93:9
   |
91 |     def test_terminal(self):
92 |         assert CheckStatus.SUCCESS.is_terminal
93 |         assert CheckStatus.FAILURE.is_terminal
   |         ^^^^^^
94 |         assert not CheckStatus.PENDING.is_terminal
95 |         assert not CheckStatus.UNKNOWN.is_terminal
   |

S101 Use of `assert` detected
  --> tools/dao-arbiter/dao_lifebook/tests.py:94:9
   |
92 |         assert CheckStatus.SUCCESS.is_terminal
93 |         assert CheckStatus.FAILURE.is_terminal
94 |         assert not CheckStatus.PENDING.is_terminal
   |         ^^^^^^
95 |         assert not CheckStatus.UNKNOWN.is_terminal
   |

S101 Use of `assert` detected
  --> tools/dao-arbiter/dao_lifebook/tests.py:95:9
   |
93 |         assert CheckStatus.FAILURE.is_terminal
94 |         assert not CheckStatus.PENDING.is_terminal
95 |         assert not CheckStatus.UNKNOWN.is_terminal
   |         ^^^^^^
   |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:100:9
    |
 98 | class TestPhase:
 99 |     def test_ordinal_ordering(self):
100 |         assert Phase.OBSERVE.ordinal < Phase.PACKETIZE.ordinal
    |         ^^^^^^
101 |         assert Phase.PACKETIZE.ordinal < Phase.PLAN.ordinal
102 |         assert Phase.AUDIT.ordinal < Phase.DECIDE.ordinal
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:101:9
    |
 99 |     def test_ordinal_ordering(self):
100 |         assert Phase.OBSERVE.ordinal < Phase.PACKETIZE.ordinal
101 |         assert Phase.PACKETIZE.ordinal < Phase.PLAN.ordinal
    |         ^^^^^^
102 |         assert Phase.AUDIT.ordinal < Phase.DECIDE.ordinal
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:102:9
    |
100 |         assert Phase.OBSERVE.ordinal < Phase.PACKETIZE.ordinal
101 |         assert Phase.PACKETIZE.ordinal < Phase.PLAN.ordinal
102 |         assert Phase.AUDIT.ordinal < Phase.DECIDE.ordinal
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:107:9
    |
105 | class TestGovernorAction:
106 |     def test_all_values(self):
107 |         assert GovernorAction.MERGE.value == "merge"
    |         ^^^^^^
108 |         assert GovernorAction.HALT.value == "halt"
109 |         assert GovernorAction.NEXT.value == "next_loop"
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:108:9
    |
106 |     def test_all_values(self):
107 |         assert GovernorAction.MERGE.value == "merge"
108 |         assert GovernorAction.HALT.value == "halt"
    |         ^^^^^^
109 |         assert GovernorAction.NEXT.value == "next_loop"
110 |         assert GovernorAction.HOLD.value == "hold"
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:109:9
    |
107 |         assert GovernorAction.MERGE.value == "merge"
108 |         assert GovernorAction.HALT.value == "halt"
109 |         assert GovernorAction.NEXT.value == "next_loop"
    |         ^^^^^^
110 |         assert GovernorAction.HOLD.value == "hold"
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:110:9
    |
108 |         assert GovernorAction.HALT.value == "halt"
109 |         assert GovernorAction.NEXT.value == "next_loop"
110 |         assert GovernorAction.HOLD.value == "hold"
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:116:9
    |
114 |     def test_valid_hash(self):
115 |         ref = ArtifactRef(path="a.txt", sha256="a" * 64)
116 |         assert ref.sha256 == "a" * 64
    |         ^^^^^^
117 |
118 |     def test_invalid_hash_rejects(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:128:9
    |
126 |     def test_empty_hash_ok(self):
127 |         ref = ArtifactRef(path="a.txt", sha256="")
128 |         assert ref.sha256 == ""
    |         ^^^^^^
129 |
130 |     def test_from_file(self, tmp_path):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:134:9
    |
132 |         f.write_bytes(b"hello world")
133 |         ref = ArtifactRef.from_file(f)
134 |         assert len(ref.sha256) == 64
    |         ^^^^^^
135 |         # Verify deterministic
136 |         assert ref.sha256 == hashlib.sha256(b"hello world").hexdigest()
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:136:9
    |
134 |         assert len(ref.sha256) == 64
135 |         # Verify deterministic
136 |         assert ref.sha256 == hashlib.sha256(b"hello world").hexdigest()
    |         ^^^^^^
137 |
138 |     def test_frozen(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:147:9
    |
145 |     def test_valid(self):
146 |         ts = TargetState(goal="Fix CI", done_when=["All checks green"])
147 |         assert ts.goal == "Fix CI"
    |         ^^^^^^
148 |
149 |     def test_empty_goal_fails(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:159:9
    |
157 |     def test_auto_detect_required(self):
158 |         ts = TargetState(goal="Fix", done_when=["Checks pass"])
159 |         assert ts.required_checks == "auto-detect from PR"
    |         ^^^^^^
160 |
161 |     def test_explicit_required_checks(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:163:9
    |
161 |     def test_explicit_required_checks(self):
162 |         ts = TargetState(goal="Fix", done_when=["Checks pass"], required_checks=["lint", "test"])
163 |         assert ts.required_checks == ["lint", "test"]
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:169:9
    |
167 |     def test_defaults(self):
168 |         c = Constraints()
169 |         assert c.touch_allowlist == ["*"]
    |         ^^^^^^
170 |         assert c.diff_budget.max_files == 20
171 |         assert c.refactor_policy == RefactorPolicy.NO_REFACTOR
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:170:9
    |
168 |         c = Constraints()
169 |         assert c.touch_allowlist == ["*"]
170 |         assert c.diff_budget.max_files == 20
    |         ^^^^^^
171 |         assert c.refactor_policy == RefactorPolicy.NO_REFACTOR
172 |         assert c.security_policy.no_disable_security_checks is True
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:171:9
    |
169 |         assert c.touch_allowlist == ["*"]
170 |         assert c.diff_budget.max_files == 20
171 |         assert c.refactor_policy == RefactorPolicy.NO_REFACTOR
    |         ^^^^^^
172 |         assert c.security_policy.no_disable_security_checks is True
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:172:9
    |
170 |         assert c.diff_budget.max_files == 20
171 |         assert c.refactor_policy == RefactorPolicy.NO_REFACTOR
172 |         assert c.security_policy.no_disable_security_checks is True
    |         ^^^^^^
173 |
174 |     def test_frozen(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:187:9
    |
185 |             done_when="lint check passes",
186 |         )
187 |         assert fp.severity == 0
    |         ^^^^^^
188 |
189 |     def test_insufficient_signal_rejects(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:219:9
    |
217 |             t_green=datetime(2026, 1, 1, 0, 5, tzinfo=timezone.utc),
218 |         )
219 |         assert ts.duration_seconds == 300.0
    |         ^^^^^^
220 |
221 |     def test_no_green_no_duration(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:223:9
    |
221 |     def test_no_green_no_duration(self):
222 |         ts = TimeSpan(t_start=datetime(2026, 1, 1, tzinfo=timezone.utc))
223 |         assert ts.duration_seconds is None
    |         ^^^^^^
224 |
225 |     def test_naive_datetime_promoted_to_utc(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:227:9
    |
225 |     def test_naive_datetime_promoted_to_utc(self):
226 |         ts = TimeSpan(t_start=datetime(2026, 1, 1))
227 |         assert ts.t_start.tzinfo is not None
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:245:9
    |
244 |     def test_all_green(self):
245 |         assert self._make_bundle(green=True).all_green
    |         ^^^^^^
246 |
247 |     def test_not_green(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:248:9
    |
247 |     def test_not_green(self):
248 |         assert not self._make_bundle(green=False).all_green
    |         ^^^^^^
249 |
250 |     def test_empty_checks_not_green(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:259:9
    |
257 |             time=TimeSpan(t_start=datetime(2026, 1, 1, tzinfo=timezone.utc)),
258 |         )
259 |         assert not bundle.all_green
    |         ^^^^^^
260 |
261 |     def test_integrity_hash_deterministic(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:265:9
    |
263 |         h1 = b.integrity_hash()
264 |         h2 = b.integrity_hash()
265 |         assert h1 == h2
    |         ^^^^^^
266 |         assert len(h1) == 64
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:266:9
    |
264 |         h2 = b.integrity_hash()
265 |         assert h1 == h2
266 |         assert len(h1) == 64
    |         ^^^^^^
267 |
268 |     def test_integrity_hash_uses_sorted_keys(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:275:9
    |
273 |         canonical = json.dumps(data, sort_keys=True, separators=(",", ":"), default=str)
274 |         expected = hashlib.sha256(canonical.encode("utf-8")).hexdigest()
275 |         assert b.integrity_hash() == expected
    |         ^^^^^^
276 |
277 |     def test_schema_version_excluded_from_hash(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:282:9
    |
280 |         h1 = b1.integrity_hash()
281 |         # The hash should be stable regardless of schema_version
282 |         assert len(h1) == 64
    |         ^^^^^^
283 |
284 |     def test_has_schema_version(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:286:9
    |
284 |     def test_has_schema_version(self):
285 |         b = self._make_bundle()
286 |         assert b.schema_version == SCHEMA_VERSION
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:292:9
    |
290 |     def test_create(self):
291 |         d = GovernorDecision(action=GovernorAction.MERGE, reason="all good")
292 |         assert d.action == GovernorAction.MERGE
    |         ^^^^^^
293 |         assert d.reason == "all good"
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:293:9
    |
291 |         d = GovernorDecision(action=GovernorAction.MERGE, reason="all good")
292 |         assert d.action == GovernorAction.MERGE
293 |         assert d.reason == "all good"
    |         ^^^^^^
294 |
295 |     def test_frozen(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:302:9
    |
300 |     def test_repr(self):
301 |         d = GovernorDecision(action=GovernorAction.HOLD, reason="review")
302 |         assert "hold" in repr(d)
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:315:9
    |
313 |         state = self._make_state()
314 |         state.record("TEST_EVENT", key="val")
315 |         assert len(state.history) == 1
    |         ^^^^^^
316 |         assert state.history[0].event == "TEST_EVENT"
317 |         assert state.history[0].data["key"] == "val"
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:316:9
    |
314 |         state.record("TEST_EVENT", key="val")
315 |         assert len(state.history) == 1
316 |         assert state.history[0].event == "TEST_EVENT"
    |         ^^^^^^
317 |         assert state.history[0].data["key"] == "val"
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:317:9
    |
315 |         assert len(state.history) == 1
316 |         assert state.history[0].event == "TEST_EVENT"
317 |         assert state.history[0].data["key"] == "val"
    |         ^^^^^^
318 |
319 |     def test_halt(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:322:9
    |
320 |         state = self._make_state()
321 |         state.halt("budget exceeded")
322 |         assert state.halted
    |         ^^^^^^
323 |         assert state.phase == Phase.HALTED
324 |         assert "budget" in state.halt_reason
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:323:9
    |
321 |         state.halt("budget exceeded")
322 |         assert state.halted
323 |         assert state.phase == Phase.HALTED
    |         ^^^^^^
324 |         assert "budget" in state.halt_reason
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:324:9
    |
322 |         assert state.halted
323 |         assert state.phase == Phase.HALTED
324 |         assert "budget" in state.halt_reason
    |         ^^^^^^
325 |
326 |     def test_history_bounded(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:331:9
    |
329 |         for i in range(3000):
330 |             state.record(f"EVENT_{i}")
331 |         assert len(state.history) <= 2000
    |         ^^^^^^
332 |
333 |     def test_structured_history_events(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:338:9
    |
336 |         state.record("TEST", x=1)
337 |         event = state.history[0]
338 |         assert isinstance(event, HistoryEvent)
    |         ^^^^^^
339 |         assert event.ts.tzinfo is not None
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:339:9
    |
337 |         event = state.history[0]
338 |         assert isinstance(event, HistoryEvent)
339 |         assert event.ts.tzinfo is not None
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:355:9
    |
353 |     def test_wildcard_allows_all(self):
354 |         e = self._enforcer()
355 |         assert e.check_path("any/path/file.py") is None
    |         ^^^^^^
356 |
357 |     def test_denylist_blocks(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:360:9
    |
358 |         e = self._enforcer(touch_denylist=["secrets/**"])
359 |         v = e.check_path("secrets/key.pem")
360 |         assert v is not None
    |         ^^^^^^
361 |         assert v.rule == EC.PATH_DENIED
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:361:9
    |
359 |         v = e.check_path("secrets/key.pem")
360 |         assert v is not None
361 |         assert v.rule == EC.PATH_DENIED
    |         ^^^^^^
362 |
363 |     def test_allowlist_restricts(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:366:9
    |
364 |         e = self._enforcer(touch_allowlist=["src/*"])
365 |         v = e.check_path("tests/test.py")
366 |         assert v is not None
    |         ^^^^^^
367 |         assert v.rule == EC.PATH_NOT_ALLOWED
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:367:9
    |
365 |         v = e.check_path("tests/test.py")
366 |         assert v is not None
367 |         assert v.rule == EC.PATH_NOT_ALLOWED
    |         ^^^^^^
368 |
369 |     def test_deny_takes_priority_over_allow(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:376:9
    |
374 |         )
375 |         v = e.check_path("config.secret")
376 |         assert v is not None
    |         ^^^^^^
377 |
378 |     def test_diff_budget_ok(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:381:9
    |
379 |         e = self._enforcer()
380 |         vs = e.check_diff(DiffSummary(files_changed=5, loc_delta=100))
381 |         assert vs == []
    |         ^^^^^^
382 |
383 |     def test_diff_budget_exceeded(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:386:9
    |
384 |         e = self._enforcer(diff_budget=DiffBudget(max_files=2, max_loc=50))
385 |         vs = e.check_diff(DiffSummary(files_changed=5, loc_delta=100))
386 |         assert len(vs) == 2
    |         ^^^^^^
387 |
388 |     def test_negative_loc_delta_exceeds_budget(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:392:9
    |
390 |         e = self._enforcer(diff_budget=DiffBudget(max_files=100, max_loc=50))
391 |         vs = e.check_diff(DiffSummary(files_changed=1, loc_delta=-100))
392 |         assert len(vs) == 1
    |         ^^^^^^
393 |
394 |     def test_refactor_blocked(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:397:9
    |
395 |         e = self._enforcer(refactor_policy=RefactorPolicy.NO_REFACTOR)
396 |         v = e.check_refactor(has_refactor=True)
397 |         assert v is not None
    |         ^^^^^^
398 |
399 |     def test_refactor_allowed(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:402:9
    |
400 |         e = self._enforcer(refactor_policy=RefactorPolicy.ALLOWED)
401 |         v = e.check_refactor(has_refactor=True)
402 |         assert v is None
    |         ^^^^^^
403 |
404 |     def test_security_violations(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:410:9
    |
408 |             unpinned_actions=["actions/checkout@main"],
409 |         )
410 |         assert len(vs) == 2
    |         ^^^^^^
411 |
412 |     def test_full_sweep(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:421:9
    |
419 |             diff=DiffSummary(files_changed=5, loc_delta=100),
420 |         )
421 |         assert len(vs) >= 3
    |         ^^^^^^
422 |
423 |     def test_violation_to_error(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:426:9
    |
424 |         v = Violation(rule="TEST_RULE", detail="bad")
425 |         err = v.to_error()
426 |         assert isinstance(err, DAOError)
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:446:9
    |
444 |             t_green=datetime.now(timezone.utc),
445 |         )
446 |         assert bundle.all_green
    |         ^^^^^^
447 |
448 |     def test_validate_incomplete(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:457:9
    |
455 |         )
456 |         issues = ProofAssembler.validate(bundle)
457 |         assert len(issues) >= 3
    |         ^^^^^^
458 |
459 |     def test_validate_non_green(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:468:9
    |
466 |         )
467 |         issues = ProofAssembler.validate(bundle)
468 |         assert any("Non-green" in i for i in issues)
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:488:9
    |
486 |         bundle = self._make_bundle()
487 |         result = store.save_bundle(bundle)
488 |         assert result.is_ok()
    |         ^^^^^^
489 |         h = result.unwrap()
490 |         assert len(h) == 64
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:490:9
    |
488 |         assert result.is_ok()
489 |         h = result.unwrap()
490 |         assert len(h) == 64
    |         ^^^^^^
491 |
492 |         load_result = store.load_bundle(h[:8])
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:493:9
    |
492 |         load_result = store.load_bundle(h[:8])
493 |         assert load_result.is_ok()
    |         ^^^^^^
494 |         loaded = load_result.unwrap()
495 |         assert loaded is not None
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:495:9
    |
493 |         assert load_result.is_ok()
494 |         loaded = load_result.unwrap()
495 |         assert loaded is not None
    |         ^^^^^^
496 |         assert loaded.commit_sha == "abc1234"
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:496:9
    |
494 |         loaded = load_result.unwrap()
495 |         assert loaded is not None
496 |         assert loaded.commit_sha == "abc1234"
    |         ^^^^^^
497 |
498 |     def test_idempotent_save(self, tmp_path):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:503:9
    |
501 |         h1 = store.save_bundle(bundle).unwrap()
502 |         h2 = store.save_bundle(bundle).unwrap()
503 |         assert h1 == h2
    |         ^^^^^^
504 |
505 |     def test_ledger(self, tmp_path):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:510:9
    |
508 |         store.save_bundle(bundle)
509 |         entries = store.list_bundles()
510 |         assert len(entries) == 1
    |         ^^^^^^
511 |         assert "schema_version" in entries[0]
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:511:9
    |
509 |         entries = store.list_bundles()
510 |         assert len(entries) == 1
511 |         assert "schema_version" in entries[0]
    |         ^^^^^^
512 |
513 |     def test_state_snapshot(self, tmp_path):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:520:9
    |
518 |         )
519 |         result = store.save_state(state, "test_snap")
520 |         assert result.is_ok()
    |         ^^^^^^
521 |
522 |         load_result = store.load_state("test_snap")
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:523:9
    |
522 |         load_result = store.load_state("test_snap")
523 |         assert load_result.is_ok()
    |         ^^^^^^
524 |         loaded = load_result.unwrap()
525 |         assert loaded is not None
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:525:9
    |
523 |         assert load_result.is_ok()
524 |         loaded = load_result.unwrap()
525 |         assert loaded is not None
    |         ^^^^^^
526 |         assert loaded.target.goal == "test"
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:526:9
    |
524 |         loaded = load_result.unwrap()
525 |         assert loaded is not None
526 |         assert loaded.target.goal == "test"
    |         ^^^^^^
527 |
528 |     def test_artifact_verify(self, tmp_path):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:533:9
    |
531 |         f.write_bytes(b"test data")
532 |         ref = ArtifactRef.from_file(f)
533 |         assert store.verify_artifact(ref)
    |         ^^^^^^
534 |
535 |         # Tamper
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:537:9
    |
535 |         # Tamper
536 |         f.write_bytes(b"tampered")
537 |         assert not store.verify_artifact(ref)
    |         ^^^^^^
538 |
539 |     def test_missing_artifact(self, tmp_path):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:542:9
    |
540 |         store = CheckpointStore(tmp_path / "evidence")
541 |         ref = ArtifactRef(path="/nonexistent/file", sha256="a" * 64)
542 |         assert not store.verify_artifact(ref)
    |         ^^^^^^
543 |
544 |     def test_load_nonexistent_bundle(self, tmp_path):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:547:9
    |
545 |         store = CheckpointStore(tmp_path / "evidence")
546 |         result = store.load_bundle("nonexistent")
547 |         assert result.is_ok()
    |         ^^^^^^
548 |         assert result.unwrap() is None
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:548:9
    |
546 |         result = store.load_bundle("nonexistent")
547 |         assert result.is_ok()
548 |         assert result.unwrap() is None
    |         ^^^^^^
549 |
550 |     def test_load_nonexistent_state(self, tmp_path):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:553:9
    |
551 |         store = CheckpointStore(tmp_path / "evidence")
552 |         result = store.load_state("nonexistent")
553 |         assert result.is_ok()
    |         ^^^^^^
554 |         assert result.unwrap() is None
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:554:9
    |
552 |         result = store.load_state("nonexistent")
553 |         assert result.is_ok()
554 |         assert result.unwrap() is None
    |         ^^^^^^
555 |
556 |     def test_list_states_empty(self, tmp_path):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:558:9
    |
556 |     def test_list_states_empty(self, tmp_path):
557 |         store = CheckpointStore(tmp_path / "evidence")
558 |         assert store.list_states() == []
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:571:9
    |
569 |     def test_kpd_zero_when_no_data(self):
570 |         m = LoopMetrics()
571 |         assert m.kpd == 0.0
    |         ^^^^^^
572 |
573 |     def test_kpd_calculation(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:585:9
    |
583 |         # penalty = 1 + 100/500 + 2/10 = 1.4
584 |         # kpd = 5/1.4  3.5714
585 |         assert 3.5 < m.kpd < 3.6
    |         ^^^^^^
586 |
587 |     def test_kpd_zero_closures(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:592:9
    |
590 |         m.t_green = datetime(2026, 1, 1, 1, 0, tzinfo=timezone.utc)
591 |         m.closures = 0
592 |         assert m.kpd == 0.0
    |         ^^^^^^
593 |
594 |     def test_kpd_near_zero_time(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:600:9
    |
598 |         m.t_green = m.t_start  # 0 seconds
599 |         m.closures = 5
600 |         assert m.kpd == 0.0  # < 0.001s threshold
    |         ^^^^^^
601 |
602 |     def test_rework_ratio(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:606:9
    |
604 |         m.total_iterations = 10
605 |         m.rework_iterations = 3
606 |         assert m.r_rework == 0.3
    |         ^^^^^^
607 |
608 |     def test_rework_ratio_zero_iterations(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:610:9
    |
608 |     def test_rework_ratio_zero_iterations(self):
609 |         m = LoopMetrics()
610 |         assert m.r_rework == 0.0
    |         ^^^^^^
611 |
612 |     def test_record_iteration(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:616:9
    |
614 |         m.record_iteration(closed=2, new_failures=False)
615 |         m.record_iteration(closed=1, new_failures=True)
616 |         assert m.total_iterations == 2
    |         ^^^^^^
617 |         assert m.closures == 3
618 |         assert m.rework_iterations == 1
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:617:9
    |
615 |         m.record_iteration(closed=1, new_failures=True)
616 |         assert m.total_iterations == 2
617 |         assert m.closures == 3
    |         ^^^^^^
618 |         assert m.rework_iterations == 1
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:618:9
    |
616 |         assert m.total_iterations == 2
617 |         assert m.closures == 3
618 |         assert m.rework_iterations == 1
    |         ^^^^^^
619 |
620 |     def test_summary_keys(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:626:9
    |
624 |                          "r_rework", "closures", "kpd", "total_iterations",
625 |                          "rework_iterations"}
626 |         assert set(s.keys()) == expected_keys
    |         ^^^^^^
627 |
628 |     def test_start_idempotent(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:634:9
    |
632 |         time.sleep(0.01)
633 |         m.start()
634 |         assert m.t_start == t1  # Not overwritten
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:649:9
    |
648 |         ledger.record("hash123", m, pr="test")
649 |         assert ledger.total_closures == 3
    |         ^^^^^^
650 |         assert ledger.avg_kpd > 0
651 |         assert ledger.total_iterations == 5
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:650:9
    |
648 |         ledger.record("hash123", m, pr="test")
649 |         assert ledger.total_closures == 3
650 |         assert ledger.avg_kpd > 0
    |         ^^^^^^
651 |         assert ledger.total_iterations == 5
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:651:9
    |
649 |         assert ledger.total_closures == 3
650 |         assert ledger.avg_kpd > 0
651 |         assert ledger.total_iterations == 5
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:673:9
    |
671 |         ]
672 |         packets = Scout().execute(state, all_checks=checks)
673 |         assert len(packets) == 2
    |         ^^^^^^
674 |         names = {p.check_name for p in packets}
675 |         assert names == {"lint", "build"}
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:675:9
    |
673 |         assert len(packets) == 2
674 |         names = {p.check_name for p in packets}
675 |         assert names == {"lint", "build"}
    |         ^^^^^^
676 |
677 |     def test_harvest_empty_on_all_green(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:684:9
    |
682 |         checks = [CheckResult(name="ci", status=CheckStatus.SUCCESS)]
683 |         packets = Scout().execute(state, all_checks=checks)
684 |         assert packets == []
    |         ^^^^^^
685 |
686 |     def test_skipped_excluded(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:696:9
    |
694 |         ]
695 |         packets = Scout().execute(state, all_checks=checks)
696 |         assert packets == []
    |         ^^^^^^
697 |
698 |     def test_sorted_by_severity_then_name(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:708:9
    |
706 |         ]
707 |         packets = Scout().execute(state, all_checks=checks)
708 |         assert packets[0].check_name == "a-check"
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:722:9
    |
720 |         ]
721 |         plan = Planner().execute(state, packets=packets)
722 |         assert len(plan) == 1
    |         ^^^^^^
723 |         assert plan[0]["packet_id"] == "FP-001"
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:723:9
    |
721 |         plan = Planner().execute(state, packets=packets)
722 |         assert len(plan) == 1
723 |         assert plan[0]["packet_id"] == "FP-001"
    |         ^^^^^^
724 |
725 |     def test_closed_packets_excluded(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:739:9
    |
737 |         ]
738 |         plan = Planner().execute(state, packets=packets)
739 |         assert len(plan) == 1
    |         ^^^^^^
740 |         assert plan[0]["packet_id"] == "FP-002"
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:740:9
    |
738 |         plan = Planner().execute(state, packets=packets)
739 |         assert len(plan) == 1
740 |         assert plan[0]["packet_id"] == "FP-002"
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:755:9
    |
753 |             touched_files=["src/main.py"],
754 |         )
755 |         assert verdict == AuditVerdict.OK
    |         ^^^^^^
756 |         assert len(findings) == 0
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:756:9
    |
754 |         )
755 |         assert verdict == AuditVerdict.OK
756 |         assert len(findings) == 0
    |         ^^^^^^
757 |
758 |     def test_failing_check_needs_change(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:769:9
    |
767 |             touched_files=[],
768 |         )
769 |         assert verdict == AuditVerdict.NEEDS_CHANGE
    |         ^^^^^^
770 |
771 |     def test_skipped_check_is_risk(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:785:9
    |
783 |             touched_files=[],
784 |         )
785 |         assert verdict == AuditVerdict.RISK
    |         ^^^^^^
786 |         assert any("skipped" in f.lower() or "Skipped" in f for f in findings)
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:786:9
    |
784 |         )
785 |         assert verdict == AuditVerdict.RISK
786 |         assert any("skipped" in f.lower() or "Skipped" in f for f in findings)
    |         ^^^^^^
787 |
788 |     def test_constraint_violation_needs_change(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:801:9
    |
799 |             enforcer=enforcer,
800 |         )
801 |         assert verdict == AuditVerdict.NEEDS_CHANGE
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:814:9
    |
812 |     def test_parse_url(self):
813 |         ref = PRRef.parse("https://github.com/owner/repo/pull/42")
814 |         assert ref.owner == "owner"
    |         ^^^^^^
815 |         assert ref.repo == "repo"
816 |         assert ref.number == 42
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:815:9
    |
813 |         ref = PRRef.parse("https://github.com/owner/repo/pull/42")
814 |         assert ref.owner == "owner"
815 |         assert ref.repo == "repo"
    |         ^^^^^^
816 |         assert ref.number == 42
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:816:9
    |
814 |         assert ref.owner == "owner"
815 |         assert ref.repo == "repo"
816 |         assert ref.number == 42
    |         ^^^^^^
817 |
818 |     def test_parse_shorthand(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:820:9
    |
818 |     def test_parse_shorthand(self):
819 |         ref = PRRef.parse("owner/repo#42")
820 |         assert ref.owner == "owner"
    |         ^^^^^^
821 |         assert ref.number == 42
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:821:9
    |
819 |         ref = PRRef.parse("owner/repo#42")
820 |         assert ref.owner == "owner"
821 |         assert ref.number == 42
    |         ^^^^^^
822 |
823 |     def test_parse_invalid(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:829:9
    |
827 |     def test_html_url(self):
828 |         ref = PRRef(owner="o", repo="r", number=1)
829 |         assert ref.html_url == "https://github.com/o/r/pull/1"
    |         ^^^^^^
830 |
831 |     def test_api_base(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:833:9
    |
831 |     def test_api_base(self):
832 |         ref = PRRef(owner="o", repo="r", number=1)
833 |         assert ref.api_base == "https://api.github.com/repos/o/r"
    |         ^^^^^^
834 |
835 |     @given(st.integers(min_value=1, max_value=100000))
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:838:9
    |
836 |     def test_parse_roundtrip(self, n):
837 |         ref = PRRef.parse(f"owner/repo#{n}")
838 |         assert ref.number == n
    |         ^^^^^^
839 |         reparsed = PRRef.parse(ref.html_url)
840 |         assert reparsed.number == n
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:840:9
    |
838 |         assert ref.number == n
839 |         reparsed = PRRef.parse(ref.html_url)
840 |         assert reparsed.number == n
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:846:9
    |
844 |     def test_run_success(self):
845 |         result = LocalGate.run("echo hello")
846 |         assert result.exit_code == 0
    |         ^^^^^^
847 |         assert result.passed
848 |         assert "hello" in result.log_tail
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:847:9
    |
845 |         result = LocalGate.run("echo hello")
846 |         assert result.exit_code == 0
847 |         assert result.passed
    |         ^^^^^^
848 |         assert "hello" in result.log_tail
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:848:9
    |
846 |         assert result.exit_code == 0
847 |         assert result.passed
848 |         assert "hello" in result.log_tail
    |         ^^^^^^
849 |
850 |     def test_run_failure(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:852:9
    |
850 |     def test_run_failure(self):
851 |         result = LocalGate.run("false")
852 |         assert result.exit_code != 0
    |         ^^^^^^
853 |         assert not result.passed
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:853:9
    |
851 |         result = LocalGate.run("false")
852 |         assert result.exit_code != 0
853 |         assert not result.passed
    |         ^^^^^^
854 |
855 |     def test_run_timeout(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:857:9
    |
855 |     def test_run_timeout(self):
856 |         result = LocalGate.run("sleep 10", timeout=0.1)
857 |         assert result.exit_code == 124
    |         ^^^^^^
858 |         assert not result.passed
859 |         assert "TIMEOUT" in result.log_tail
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:858:9
    |
856 |         result = LocalGate.run("sleep 10", timeout=0.1)
857 |         assert result.exit_code == 124
858 |         assert not result.passed
    |         ^^^^^^
859 |         assert "TIMEOUT" in result.log_tail
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:859:9
    |
857 |         assert result.exit_code == 124
858 |         assert not result.passed
859 |         assert "TIMEOUT" in result.log_tail
    |         ^^^^^^
860 |
861 |     def test_run_command_not_found(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:863:9
    |
861 |     def test_run_command_not_found(self):
862 |         result = LocalGate.run("nonexistent_command_xyz_12345")
863 |         assert result.exit_code != 0
    |         ^^^^^^
864 |         assert not result.passed
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:864:9
    |
862 |         result = LocalGate.run("nonexistent_command_xyz_12345")
863 |         assert result.exit_code != 0
864 |         assert not result.passed
    |         ^^^^^^
865 |
866 |     def test_run_returns_structured_result(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:869:9
    |
867 |         """v2: returns LocalGateResult, not tuple."""
868 |         result = LocalGate.run("echo test")
869 |         assert isinstance(result, LocalGateResult)
    |         ^^^^^^
870 |
871 |     def test_shell_expression(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:874:9
    |
872 |         """Commands with pipes use shell mode."""
873 |         result = LocalGate.run("echo hello | cat")
874 |         assert result.exit_code == 0
    |         ^^^^^^
875 |         assert "hello" in result.log_tail
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:875:9
    |
873 |         result = LocalGate.run("echo hello | cat")
874 |         assert result.exit_code == 0
875 |         assert "hello" in result.log_tail
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:888:9
    |
886 |     def test_starts_closed(self):
887 |         cb = CircuitBreaker()
888 |         assert cb.state == "closed"
    |         ^^^^^^
889 |         assert cb.allow_request()
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:889:9
    |
887 |         cb = CircuitBreaker()
888 |         assert cb.state == "closed"
889 |         assert cb.allow_request()
    |         ^^^^^^
890 |
891 |     def test_opens_after_threshold(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:895:9
    |
893 |         for _ in range(3):
894 |             cb.record_failure()
895 |         assert cb.state == "open"
    |         ^^^^^^
896 |         assert not cb.allow_request()
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:896:9
    |
894 |             cb.record_failure()
895 |         assert cb.state == "open"
896 |         assert not cb.allow_request()
    |         ^^^^^^
897 |
898 |     def test_success_resets(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:902:9
    |
900 |         cb.record_failure()
901 |         cb.record_success()
902 |         assert cb.state == "closed"
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:908:9
    |
906 |     def test_success_on_first_try(self):
907 |         result = retry_with_backoff(lambda: 42)
908 |         assert result.is_ok()
    |         ^^^^^^
909 |         assert result.unwrap() == 42
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:909:9
    |
907 |         result = retry_with_backoff(lambda: 42)
908 |         assert result.is_ok()
909 |         assert result.unwrap() == 42
    |         ^^^^^^
910 |
911 |     def test_fails_after_max_attempts(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:920:9
    |
918 |         cfg = RetryConfig(max_attempts=2, base_delay=0.01)
919 |         result = retry_with_backoff(failing, config=cfg)
920 |         assert result.is_err()
    |         ^^^^^^
921 |         assert call_count == 2
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:921:9
    |
919 |         result = retry_with_backoff(failing, config=cfg)
920 |         assert result.is_err()
921 |         assert call_count == 2
    |         ^^^^^^
922 |
923 |     def test_eventual_success(self):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:934:9
    |
932 |         cfg = RetryConfig(max_attempts=5, base_delay=0.01)
933 |         result = retry_with_backoff(flaky, config=cfg)
934 |         assert result.is_ok()
    |         ^^^^^^
935 |         assert result.unwrap() == "ok"
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:935:9
    |
933 |         result = retry_with_backoff(flaky, config=cfg)
934 |         assert result.is_ok()
935 |         assert result.unwrap() == "ok"
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:977:9
    |
975 |             touched_files=["src/a.py", "src/b.py"],
976 |         )
977 |         assert decision.action == GovernorAction.MERGE
    |         ^^^^^^
978 |
979 |     def test_failing_goes_next(self, tmp_path):
    |

S101 Use of `assert` detected
   --> tools/dao-arbiter/dao_lifebook/tests.py:992:9
    |
990 |             touched_files=["src/a.py"],
991 |         )
992 |         assert decision.action == GovernorAction.NEXT
    |         ^^^^^^
993 |
994 |     def test_max_iterations_halt(self, tmp_path):
    |

S101 Use of `assert` detected
    --> tools/dao-arbiter/dao_lifebook/tests.py:1012:9
     |
1010 |             touched_files=["a.py"],
1011 |         )
1012 |         assert decision.action == GovernorAction.HALT
     |         ^^^^^^
1013 |
1014 |     def test_can_stop(self, tmp_path):
     |

S101 Use of `assert` detected
    --> tools/dao-arbiter/dao_lifebook/tests.py:1026:9
     |
1024 |             touched_files=["a.py"],
1025 |         )
1026 |         assert loop.can_stop()
     |         ^^^^^^
1027 |
1028 |     def test_cannot_stop_without_proof(self):
     |

S101 Use of `assert` detected
    --> tools/dao-arbiter/dao_lifebook/tests.py:1033:9
     |
1031 |             Constraints(),
1032 |         )
1033 |         assert not loop.can_stop()
     |         ^^^^^^
1034 |
1035 |     def test_checkpoint_and_stop(self, tmp_path):
     |

S101 Use of `assert` detected
    --> tools/dao-arbiter/dao_lifebook/tests.py:1048:9
     |
1046 |         )
1047 |         result = loop.checkpoint_and_stop()
1048 |         assert result["stopped"]
     |         ^^^^^^
1049 |         assert result["proof_hash"]
     |

S101 Use of `assert` detected
    --> tools/dao-arbiter/dao_lifebook/tests.py:1049:9
     |
1047 |         result = loop.checkpoint_and_stop()
1048 |         assert result["stopped"]
1049 |         assert result["proof_hash"]
     |         ^^^^^^
1050 |
1051 |     def test_governor_fn_override(self, tmp_path):
     |

S101 Use of `assert` detected
    --> tools/dao-arbiter/dao_lifebook/tests.py:1069:9
     |
1067 |             touched_files=["a.py"],
1068 |         )
1069 |         assert decision.action == GovernorAction.HOLD
     |         ^^^^^^
1070 |
1071 |     def test_constraint_halt_in_spec(self, tmp_path):
     |

S101 Use of `assert` detected
    --> tools/dao-arbiter/dao_lifebook/tests.py:1091:9
     |
1089 |         spec = Specifier().execute(state, task={"rollback": "revert"}, packet=packet)
1090 |         violations = loop.enforcer.check_paths(spec.scope_files)
1091 |         assert len(violations) > 0
     |         ^^^^^^
1092 |
1093 |     def test_rework_detection(self, tmp_path):
     |

S101 Use of `assert` detected
    --> tools/dao-arbiter/dao_lifebook/tests.py:1125:9
     |
1124 |         # Should detect rework
1125 |         assert loop.metrics.rework_iterations >= 1
     |         ^^^^^^
     |

S101 Use of `assert` detected
    --> tools/dao-arbiter/dao_lifebook/tests.py:1156:9
     |
1154 |         )
1155 |
1156 |         assert decision.action == GovernorAction.MERGE
     |         ^^^^^^
1157 |         assert loop.state.proof is not None
1158 |         assert loop.state.proof.all_green
     |

S101 Use of `assert` detected
    --> tools/dao-arbiter/dao_lifebook/tests.py:1157:9
     |
1156 |         assert decision.action == GovernorAction.MERGE
1157 |         assert loop.state.proof is not None
     |         ^^^^^^
1158 |         assert loop.state.proof.all_green
1159 |         assert loop.can_stop()
     |

S101 Use of `assert` detected
    --> tools/dao-arbiter/dao_lifebook/tests.py:1158:9
     |
1156 |         assert decision.action == GovernorAction.MERGE
1157 |         assert loop.state.proof is not None
1158 |         assert loop.state.proof.all_green
     |         ^^^^^^
1159 |         assert loop.can_stop()
     |

S101 Use of `assert` detected
    --> tools/dao-arbiter/dao_lifebook/tests.py:1159:9
     |
1157 |         assert loop.state.proof is not None
1158 |         assert loop.state.proof.all_green
1159 |         assert loop.can_stop()
     |         ^^^^^^
1160 |
1161 |         result = loop.checkpoint_and_stop()
     |

S101 Use of `assert` detected
    --> tools/dao-arbiter/dao_lifebook/tests.py:1162:9
     |
1161 |         result = loop.checkpoint_and_stop()
1162 |         assert result["stopped"]
     |         ^^^^^^
1163 |
1164 |         entries = store.list_bundles()
     |

S101 Use of `assert` detected
    --> tools/dao-arbiter/dao_lifebook/tests.py:1165:9
     |
1164 |         entries = store.list_bundles()
1165 |         assert len(entries) >= 1
     |         ^^^^^^
1166 |         assert "final" in store.list_states()
     |

S101 Use of `assert` detected
    --> tools/dao-arbiter/dao_lifebook/tests.py:1166:9
     |
1164 |         entries = store.list_bundles()
1165 |         assert len(entries) >= 1
1166 |         assert "final" in store.list_states()
     |         ^^^^^^
1167 |
1168 |     def test_fix_path(self, tmp_path):
     |

S101 Use of `assert` detected
    --> tools/dao-arbiter/dao_lifebook/tests.py:1182:9
     |
1180 |             touched_files=["a.py"],
1181 |         )
1182 |         assert d1.action == GovernorAction.NEXT
     |         ^^^^^^
1183 |
1184 |         d2 = loop.run_iteration(
     |

S101 Use of `assert` detected
    --> tools/dao-arbiter/dao_lifebook/tests.py:1190:9
     |
1188 |             touched_files=["a.py"],
1189 |         )
1190 |         assert d2.action == GovernorAction.MERGE
     |         ^^^^^^
1191 |         assert loop.state.iteration == 2
     |

S101 Use of `assert` detected
    --> tools/dao-arbiter/dao_lifebook/tests.py:1191:9
     |
1189 |         )
1190 |         assert d2.action == GovernorAction.MERGE
1191 |         assert loop.state.iteration == 2
     |         ^^^^^^
1192 |
1193 |     def test_budget_exceeded_halts(self, tmp_path):
     |

S101 Use of `assert` detected
    --> tools/dao-arbiter/dao_lifebook/tests.py:1207:9
     |
1205 |         )
1206 |         # Budget exceeded  audit finds violations  HOLD or NEXT
1207 |         assert decision.action != GovernorAction.MERGE
     |         ^^^^^^
     |

S101 Use of `assert` detected
    --> tools/dao-arbiter/dao_lifebook/tests.py:1218:9
     |
1216 |     def test_artifact_ref_valid_hex(self, hex_str):
1217 |         ref = ArtifactRef(path="test", sha256=hex_str)
1218 |         assert ref.sha256 == hex_str
     |         ^^^^^^
1219 |
1220 |     @given(st.text(min_size=1, max_size=10).filter(
     |

S101 Use of `assert` detected
    --> tools/dao-arbiter/dao_lifebook/tests.py:1242:13
     |
1241 |         if files <= max_files and abs(loc) <= max_loc:
1242 |             assert len(vs) == 0
     |             ^^^^^^
1243 |         if files > max_files:
1244 |             assert any(EC.DIFF_BUDGET in v.rule for v in vs)
     |

S101 Use of `assert` detected
    --> tools/dao-arbiter/dao_lifebook/tests.py:1244:13
     |
1242 |             assert len(vs) == 0
1243 |         if files > max_files:
1244 |             assert any(EC.DIFF_BUDGET in v.rule for v in vs)
     |             ^^^^^^
1245 |
1246 |     @given(st.integers(min_value=0, max_value=100))
     |

S101 Use of `assert` detected
    --> tools/dao-arbiter/dao_lifebook/tests.py:1254:9
     |
1252 |         m.t_green = datetime(2026, 1, 1, 1, 0, tzinfo=timezone.utc)
1253 |         m.closures = closures
1254 |         assert m.kpd >= 0.0
     |         ^^^^^^
     |

S602 `subprocess` call with `shell=True` identified, security issue
   --> tools/dao-arbiter/dao_lifebook/truth_plane.py:331:26
    |
329 |         try:
330 |             if needs_shell:
331 |                 result = subprocess.run(
    |                          ^^^^^^^^^^^^^^
332 |                     cmd,
333 |                     shell=True,
    |

S603 `subprocess` call: check for execution of untrusted input
   --> tools/dao-arbiter/dao_lifebook/truth_plane.py:340:26
    |
338 |                 )
339 |             else:
340 |                 result = subprocess.run(
    |                          ^^^^^^^^^^^^^^
341 |                     shlex.split(cmd),
342 |                     cwd=cwd,
    |

S603 `subprocess` call: check for execution of untrusted input
  --> tools/prod_spec/generate_build_artifacts.py:45:9
   |
44 | def run(cmd: list[str], cwd: Path) -> tuple[int, str]:
45 |     p = subprocess.run(cmd, cwd=str(cwd), capture_output=True, text=True)
   |         ^^^^^^^^^^^^^^
46 |     out = (p.stdout or '') + (p.stderr or '')
47 |     return p.returncode, out
   |

S112 `try`-`except`-`continue` detected, consider logging the exception
   --> tools/prod_spec/generate_formal_artifacts.py:189:9
    |
187 |           try:
188 |               txt = p.read_text(encoding='utf-8', errors='ignore')
189 | /         except Exception:
190 | |             continue
    | |____________________^
191 |           for name, rx in patterns.items():
192 |               for m in rx.finditer(txt):
    |

S105 Possible hardcoded password assigned to: "PASS"
  --> udgs_core/ad2026/gates.py:32:19
   |
31 | class GateStatus(str, Enum):
32 |     PASS        = "PASS"
   |                   ^^^^^^
33 |     FAIL        = "FAIL"
34 |     ERROR       = "ERROR"
   |

S106 Possible hardcoded password assigned to argument: "token_id"
   --> udgs_core/ad2026/runtime.py:238:13
    |
236 |         # MCP policy with default token
237 |         default_token = RCToken(
238 |             token_id="RCT-DEFAULT-001",
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^
239 |             agent_id=agent_id,
240 |             capabilities=["READ", "WRITE", "CHECKPOINT", "EMIT_PB"],
    |

S110 `try`-`except`-`pass` detected, consider logging the exception
   --> udgs_core/ad2026/runtime.py:403:13
    |
401 |                   qa8_status = self.qa8_engine.run_cycle()
402 |                   self.metrics.record_drift_correction(qa8_status.mode == Qa8Mode.NOMINAL)
403 | /             except Exception:
404 | |                 pass
    | |____________________^
405 |               ci_l9 = self.metrics.snapshot()
    |

S101 Use of `assert` detected
  --> udgs_core/cli.py:59:5
   |
57 |         result = cycle.step(ev)
58 |
59 |     assert result is not None
   |     ^^^^^^
60 |     out = {
61 |         "next_state": result.next_state.value,
   |

S106 Possible hardcoded password assigned to argument: "token_id"
   --> udgs_core/tests/test_ad2026.py:113:9
    |
111 | def mcp_policy():
112 |     token = RCToken(
113 |         token_id="TOK-001",
    |         ^^^^^^^^^^^^^^^^^^
114 |         agent_id="test-agent",
115 |         capabilities=["READ", "WRITE", "CHECKPOINT"],
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:128:9
    |
126 |     def test_generate_creates_keypair(self):
127 |         a = AAID.generate("agent-x")
128 |         assert a.agent_id == "agent-x"
    |         ^^^^^^
129 |         assert a.env_class == ENV_CLASS_NO_TEE
130 |         assert len(a.public_id) == 32
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:129:9
    |
127 |         a = AAID.generate("agent-x")
128 |         assert a.agent_id == "agent-x"
129 |         assert a.env_class == ENV_CLASS_NO_TEE
    |         ^^^^^^
130 |         assert len(a.public_id) == 32
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:130:9
    |
128 |         assert a.agent_id == "agent-x"
129 |         assert a.env_class == ENV_CLASS_NO_TEE
130 |         assert len(a.public_id) == 32
    |         ^^^^^^
131 |
132 |     def test_sign_verify_roundtrip(self, aaid):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:135:9
    |
133 |         payload = b"test payload"
134 |         mac = aaid.sign(payload)
135 |         assert aaid.verify(payload, mac)
    |         ^^^^^^
136 |
137 |     def test_verify_wrong_payload_fails(self, aaid):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:139:9
    |
137 |     def test_verify_wrong_payload_fails(self, aaid):
138 |         mac = aaid.sign(b"correct")
139 |         assert not aaid.verify(b"tampered", mac)
    |         ^^^^^^
140 |
141 |     def test_different_agents_different_keys(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:145:9
    |
143 |         a2 = AAID.generate("a2")
144 |         payload = b"same payload"
145 |         assert a1.sign(payload) != a2.sign(payload)
    |         ^^^^^^
146 |
147 |     def test_public_id_deterministic(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:149:9
    |
147 |     def test_public_id_deterministic(self):
148 |         a = AAID.generate("x")
149 |         assert a.public_id == a.public_id
    |         ^^^^^^
150 |
151 |     def test_as_public_dict_no_secret(self, aaid):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:153:9
    |
151 |     def test_as_public_dict_no_secret(self, aaid):
152 |         d = aaid.as_public_dict()
153 |         assert "agent_id" in d
    |         ^^^^^^
154 |         assert "_secret" not in str(d)
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:154:9
    |
152 |         d = aaid.as_public_dict()
153 |         assert "agent_id" in d
154 |         assert "_secret" not in str(d)
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:160:9
    |
158 |     def test_sign_verify_ac(self, ac_root_key, ac):
159 |         sig = ac_root_key.sign_ac(ac.canonical_bytes())
160 |         assert ac_root_key.verify_ac(ac.canonical_bytes(), sig)
    |         ^^^^^^
161 |
162 |     def test_wrong_ac_fails_verify(self, ac_root_key, ac):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:165:9
    |
163 |         sig = ac_root_key.sign_ac(ac.canonical_bytes())
164 |         tampered = ac.canonical_bytes() + b"x"
165 |         assert not ac_root_key.verify_ac(tampered, sig)
    |         ^^^^^^
166 |
167 |     def test_save_load_roundtrip(self, tmp_path, ac_root_key, ac):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:172:9
    |
170 |         loaded = ACRootKey.load(path)
171 |         sig = loaded.sign_ac(ac.canonical_bytes())
172 |         assert ac_root_key.verify_ac(ac.canonical_bytes(), sig)
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:180:9
    |
178 |         token = jws_sign(payload, aaid)
179 |         valid, decoded = jws_verify(token, aaid)
180 |         assert valid
    |         ^^^^^^
181 |         assert decoded["action"] == "test"
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:181:9
    |
179 |         valid, decoded = jws_verify(token, aaid)
180 |         assert valid
181 |         assert decoded["action"] == "test"
    |         ^^^^^^
182 |
183 |     def test_tampered_payload_fails(self, aaid):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:191:9
    |
189 |         tampered = f"{parts[0]}.{bad}.{parts[2]}"
190 |         valid, _ = jws_verify(tampered, aaid)
191 |         assert not valid
    |         ^^^^^^
192 |
193 |     def test_wrong_agent_fails(self, aaid):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:197:9
    |
195 |         other = AAID.generate("other")
196 |         valid, _ = jws_verify(token, other)
197 |         assert not valid
    |         ^^^^^^
198 |
199 |     def test_three_part_structure(self, aaid):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:201:9
    |
199 |     def test_three_part_structure(self, aaid):
200 |         token = jws_sign({}, aaid)
201 |         assert len(token.split(".")) == 3
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:217:9
    |
215 |         b1 = chain.append({"in":1}, {"out":1}, {"G6":"PASS"})
216 |         b2 = chain.append({"in":2}, {"out":2}, {"G6":"PASS"})
217 |         assert b1.monotonic_counter == 1
    |         ^^^^^^
218 |         assert b2.monotonic_counter == 2
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:218:9
    |
216 |         b2 = chain.append({"in":2}, {"out":2}, {"G6":"PASS"})
217 |         assert b1.monotonic_counter == 1
218 |         assert b2.monotonic_counter == 2
    |         ^^^^^^
219 |
220 |     def test_chain_continuity(self, aaid, ac):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:225:9
    |
223 |         chain.append({"in":2}, {"out":2}, {"G6":"PASS"})
224 |         valid, errors = chain.verify_chain()
225 |         assert valid, errors
    |         ^^^^^^
226 |
227 |     def test_genesis_prev_hash_empty(self, aaid, ac):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:230:9
    |
228 |         chain = self._make_chain(aaid, ac)
229 |         b = chain.append({"in":1}, {"out":1}, {})
230 |         assert b.prev_bundle_hash == ""
    |         ^^^^^^
231 |
232 |     def test_chain_break_detected(self, aaid, ac):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:237:9
    |
235 |         chain._chain[-1].prev_bundle_hash = "tampered"*8  # break chain
236 |         _, errors = chain.verify_chain()
237 |         assert len(errors) > 0
    |         ^^^^^^
238 |
239 |     def test_jws_in_every_bundle(self, aaid, ac):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:243:13
    |
241 |         for i in range(5):
242 |             b = chain.append({"i":i}, {"o":i}, {})
243 |             assert len(b.jws_token.split(".")) == 3
    |             ^^^^^^
244 |
245 |     def test_evidence_refs_attached(self, aaid, ac):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:249:9
    |
247 |         refs = [EvidenceRef(kind=EvidenceKind.LOG, id="test-001", sha256="a"*64)]
248 |         b = chain.append({"in":1}, {"out":1}, {}, evidence_refs=refs)
249 |         assert "REF:LOG#test-001" in b.evidence_refs[0]
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:259:9
    |
257 |         sig = ac_root_key.sign_ac(ac.canonical_bytes())
258 |         ok, errors = zto_verify(bundle, aaid, ac_root_key, ac.canonical_bytes(), sig, "")
259 |         assert ok, errors
    |         ^^^^^^
260 |
261 |     def test_wrong_aaid_fails(self, aaid, ac_root_key, ac):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:268:9
    |
266 |         other_aaid = AAID.generate("other")
267 |         ok, errors = zto_verify(bundle, other_aaid, ac_root_key, ac.canonical_bytes(), sig, "")
268 |         assert not ok
    |         ^^^^^^
269 |
270 |     def test_chain_break_detected(self, aaid, ac_root_key, ac):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:277:9
    |
275 |         ok, errors = zto_verify(bundle, aaid, ac_root_key, ac.canonical_bytes(), sig,
276 |                                 expected_prev_hash="wrong_hash")
277 |         assert not ok
    |         ^^^^^^
278 |         assert any("chain break" in e for e in errors)
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:278:9
    |
276 |                                 expected_prev_hash="wrong_hash")
277 |         assert not ok
278 |         assert any("chain break" in e for e in errors)
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:284:9
    |
282 |     def test_str_format(self):
283 |         ref = EvidenceRef(kind=EvidenceKind.LOG, id="test-001", sha256="a"*64)
284 |         assert str(ref) == "REF:LOG#test-001#" + "a"*64
    |         ^^^^^^
285 |
286 |     def test_roundtrip(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:288:9
    |
286 |     def test_roundtrip(self):
287 |         ref = EvidenceRef(kind=EvidenceKind.ATTEST, id="attest-xyz", sha256="f"*64)
288 |         assert EvidenceRef.from_str(str(ref)) == ref
    |         ^^^^^^
289 |
290 |     def test_from_bytes(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:292:9
    |
290 |     def test_from_bytes(self):
291 |         ref = EvidenceRef.from_bytes(EvidenceKind.TEST, "test-001", b"content")
292 |         assert len(ref.sha256) == 64
    |         ^^^^^^
293 |
294 |     def test_invalid_ref_raises(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:315:9
    |
313 |         )
314 |         d = a.as_dict()
315 |         assert d["action_type"] == "DEPLOY"
    |         ^^^^^^
316 |         assert d["rollback_action_id"] == "RB-1"
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:316:9
    |
314 |         d = a.as_dict()
315 |         assert d["action_type"] == "DEPLOY"
316 |         assert d["rollback_action_id"] == "RB-1"
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:321:9
    |
319 | class TestSPS:
320 |     def test_sha256_deterministic(self, sample_sps):
321 |         assert sample_sps.sha256() == sample_sps.sha256()
    |         ^^^^^^
322 |
323 |     def test_sha256_changes_on_mutation(self, sample_sps):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:330:9
    |
328 |             invariants_touched=[], rollback_action_id="NOOP",
329 |         ))
330 |         assert sample_sps.sha256() != h1
    |         ^^^^^^
331 |
332 |     def test_canonical_bytes_stable(self, sample_sps):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:333:9
    |
332 |     def test_canonical_bytes_stable(self, sample_sps):
333 |         assert sample_sps.canonical_bytes() == sample_sps.canonical_bytes()
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:340:9
    |
338 |         inv_set = InvariantSet()
339 |         ok, v = inv_set.evaluate(sample_sps)
340 |         assert ok and not v
    |         ^^^^^^
341 |
342 |     def test_violated_invariant_detected(self, sample_sps):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:350:9
    |
348 |         ))
349 |         ok, v = inv_set.evaluate(sample_sps)
350 |         assert not ok
    |         ^^^^^^
351 |         assert "TEST-01" in v[0]
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:351:9
    |
349 |         ok, v = inv_set.evaluate(sample_sps)
350 |         assert not ok
351 |         assert "TEST-01" in v[0]
    |         ^^^^^^
352 |
353 |     def test_all_baseline_invariants_pass_valid_sps(self, sample_sps):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:356:9
    |
354 |         inv_set = build_ac_baseline_invariants()
355 |         ok, v = inv_set.evaluate(sample_sps)
356 |         assert ok, v
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:363:9
    |
361 |         gate = SMTGate(build_ac_baseline_invariants())
362 |         result = gate.prove(sample_sps)
363 |         assert result.passed
    |         ^^^^^^
364 |
365 |     def test_empty_sps_fails_safety02(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:370:9
    |
368 |         empty_sps = SPS("EMPTY", "agent", datetime.now(tz=timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ"))
369 |         result = gate.prove(empty_sps)
370 |         assert not result.passed
    |         ^^^^^^
371 |         assert any("SAFETY-02" in v for v in result.violations)
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:371:9
    |
369 |         result = gate.prove(empty_sps)
370 |         assert not result.passed
371 |         assert any("SAFETY-02" in v for v in result.violations)
    |         ^^^^^^
372 |
373 |     def test_deploy_without_rollback_fails_safety01(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:384:9
    |
382 |         ))
383 |         result = gate.prove(sps)
384 |         assert not result.passed
    |         ^^^^^^
385 |         assert any("SAFETY-01" in v for v in result.violations)
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:385:9
    |
383 |         result = gate.prove(sps)
384 |         assert not result.passed
385 |         assert any("SAFETY-01" in v for v in result.violations)
    |         ^^^^^^
386 |
387 |     def test_kernel_mutation_fails_forbidden01(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:403:9
    |
401 |         ))
402 |         result = gate.prove(sps)
403 |         assert not result.passed
    |         ^^^^^^
404 |
405 |     def test_no_invariants_returns_error(self, sample_sps):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:408:9
    |
406 |         gate = SMTGate(InvariantSet())
407 |         result = gate.prove(sample_sps)
408 |         assert result.status == "ERROR"
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:414:9
    |
412 |     def test_valid_sps_passes(self, sample_sps):
413 |         ok, errors = SPSValidator.validate(sample_sps)
414 |         assert ok, errors
    |         ^^^^^^
415 |
416 |     def test_missing_rollback_reference_detected(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:426:9
    |
424 |         ))
425 |         ok, errors = SPSValidator.validate(sps)
426 |         assert not ok
    |         ^^^^^^
427 |         assert any("NONEXISTENT" in e for e in errors)
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:427:9
    |
425 |         ok, errors = SPSValidator.validate(sps)
426 |         assert not ok
427 |         assert any("NONEXISTENT" in e for e in errors)
    |         ^^^^^^
428 |
429 |     def test_deploy_without_evidence_detected(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:439:9
    |
437 |         ))
438 |         ok, errors = SPSValidator.validate(sps)
439 |         assert not ok
    |         ^^^^^^
440 |         assert any("evidence_refs" in e for e in errors)
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:440:9
    |
438 |         ok, errors = SPSValidator.validate(sps)
439 |         assert not ok
440 |         assert any("evidence_refs" in e for e in errors)
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:458:9
    |
456 |         g6 = G6Auth()
457 |         r = g6.run(bundle, aaid, ac_root_key, ac.canonical_bytes(), sig, "")
458 |         assert r.passed
    |         ^^^^^^
459 |
460 |     def test_wrong_aaid_fails(self, aaid, ac_root_key, ac):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:466:9
    |
464 |         other = AAID.generate("other")
465 |         r = g6.run(bundle, other, ac_root_key, ac.canonical_bytes(), sig, "")
466 |         assert not r.passed
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:473:9
    |
471 |         g7 = G7Formal(SMTGate(build_ac_baseline_invariants()))
472 |         r = g7.run(sample_sps)
473 |         assert r.passed
    |         ^^^^^^
474 |
475 |     def test_invariant_violation_fails(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:480:9
    |
478 |         sps = SPS("BAD", "a", datetime.now(tz=timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ"))
479 |         r = g7.run(sps)
480 |         assert not r.passed
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:493:9
    |
491 |         g8 = G8Sandbox()
492 |         r = g8.run(profile, fp, tc, tc)
493 |         assert r.passed
    |         ^^^^^^
494 |
495 |     def test_env_mismatch_fails(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:503:9
    |
501 |         g8 = G8Sandbox()
502 |         r = g8.run(profile, "wrong_fp"*4, "tc_hash"*8, "tc_hash"*8)
503 |         assert not r.passed
    |         ^^^^^^
504 |
505 |     def test_toolchain_mismatch_fails(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:513:9
    |
511 |         g8 = G8Sandbox()
512 |         r = g8.run(profile, fp, "expected"*8, "different"*8)
513 |         assert not r.passed
    |         ^^^^^^
    |

S106 Possible hardcoded password assigned to argument: "token_id"
   --> udgs_core/tests/test_ad2026.py:519:50
    |
517 |     def test_valid_hermetic_call_passes(self, mcp_policy):
518 |         call = MCPCallRecord(
519 |             call_id="C1", tool_name="read_file", token_id="TOK-001",
    |                                                  ^^^^^^^^^^^^^^^^^^
520 |             input_hash="a"*64, output_hash="b"*64,
521 |             timestamp_utc="2026-01-01T00:00:00Z", hermetic=True,
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:525:9
    |
523 |         g9 = G9MCP(mcp_policy)
524 |         r = g9.run([(call, "READ")])
525 |         assert r.passed
    |         ^^^^^^
526 |
527 |     def test_non_hermetic_fails(self, mcp_policy):
    |

S106 Possible hardcoded password assigned to argument: "token_id"
   --> udgs_core/tests/test_ad2026.py:529:45
    |
527 |     def test_non_hermetic_fails(self, mcp_policy):
528 |         call = MCPCallRecord(
529 |             call_id="C2", tool_name="tool", token_id="TOK-001",
    |                                             ^^^^^^^^^^^^^^^^^^
530 |             input_hash="a"*64, output_hash="b"*64,
531 |             timestamp_utc="2026-01-01T00:00:00Z", hermetic=False,
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:535:9
    |
533 |         g9 = G9MCP(mcp_policy)
534 |         r = g9.run([(call, "READ")])
535 |         assert not r.passed
    |         ^^^^^^
536 |
537 |     def test_missing_capability_fails(self, mcp_policy):
    |

S106 Possible hardcoded password assigned to argument: "token_id"
   --> udgs_core/tests/test_ad2026.py:539:45
    |
537 |     def test_missing_capability_fails(self, mcp_policy):
538 |         call = MCPCallRecord(
539 |             call_id="C3", tool_name="tool", token_id="TOK-001",
    |                                             ^^^^^^^^^^^^^^^^^^
540 |             input_hash="a"*64, output_hash="b"*64,
541 |             timestamp_utc="2026-01-01T00:00:00Z", hermetic=True,
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:545:9
    |
543 |         g9 = G9MCP(mcp_policy)
544 |         r = g9.run([(call, "EXECUTE")])  # EXECUTE not in token
545 |         assert not r.passed
    |         ^^^^^^
546 |
547 |     def test_revoked_token_fails(self, mcp_policy):
    |

S106 Possible hardcoded password assigned to argument: "token_id"
   --> udgs_core/tests/test_ad2026.py:550:45
    |
548 |         mcp_policy._tokens["TOK-001"].revoked = True
549 |         call = MCPCallRecord(
550 |             call_id="C4", tool_name="tool", token_id="TOK-001",
    |                                             ^^^^^^^^^^^^^^^^^^
551 |             input_hash="a"*64, output_hash="b"*64,
552 |             timestamp_utc="2026-01-01T00:00:00Z", hermetic=True,
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:556:9
    |
554 |         g9 = G9MCP(mcp_policy)
555 |         r = g9.run([(call, "READ")])
556 |         assert not r.passed
    |         ^^^^^^
557 |         mcp_policy._tokens["TOK-001"].revoked = False  # restore
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:571:9
    |
569 |         g10 = G10Sync()
570 |         r = g10.run(snap)
571 |         assert r.passed
    |         ^^^^^^
572 |
573 |     def test_low_precision_fails(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:582:9
    |
580 |         )
581 |         r = G10Sync().run(snap)
582 |         assert not r.passed
    |         ^^^^^^
583 |
584 |     def test_high_latency_fails(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:593:9
    |
591 |         )
592 |         r = G10Sync().run(snap)
593 |         assert not r.passed
    |         ^^^^^^
594 |
595 |     def test_mismatch_nonzero_fails(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:604:9
    |
602 |         )
603 |         r = G10Sync().run(snap)
604 |         assert not r.passed
    |         ^^^^^^
605 |
606 |     def test_ac_violations_in_window_fails(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:609:9
    |
607 |         snap = CIL9Snapshot(0.95, 0.99, 300.0, 0.995, 0)
608 |         r = G10Sync().run(snap, ac_violations_in_window=1)
609 |         assert not r.passed
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:626:9
    |
624 |         snap = self._good_snap("a"*64)
625 |         r = G11InvariantFixation().run(snap)
626 |         assert r.passed
    |         ^^^^^^
627 |
628 |     def test_integrity_not_1_fails(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:632:9
    |
630 |         snap.invariant_integrity = 0.9
631 |         r = G11InvariantFixation().run(snap)
632 |         assert not r.passed
    |         ^^^^^^
633 |
634 |     def test_ac_hash_changed_fails(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:638:9
    |
636 |         snap.ac_sha256_after = "b"*64
637 |         r = G11InvariantFixation().run(snap)
638 |         assert not r.passed
    |         ^^^^^^
639 |
640 |     def test_replay_mismatch_fails(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:644:9
    |
642 |         snap.replay_mismatch_m = 1
643 |         r = G11InvariantFixation().run(snap)
644 |         assert not r.passed
    |         ^^^^^^
645 |
646 |     def test_insufficient_n_returns_not_ready(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:651:9
    |
649 |         snap.min_replay_n = 100
650 |         r = G11InvariantFixation().run(snap)
651 |         assert r.status == GateStatus.NOT_READY
    |         ^^^^^^
652 |
653 |     def test_ssdf_regression_fails(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:657:9
    |
655 |         snap.ssdf_regression = True
656 |         r = G11InvariantFixation().run(snap)
657 |         assert not r.passed
    |         ^^^^^^
658 |
659 |     def test_nonzero_cfr_fails(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:663:9
    |
661 |         snap.change_failure_rate = 0.01
662 |         r = G11InvariantFixation().run(snap)
663 |         assert not r.passed
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:679:9
    |
677 |             m.record_planner_replay(mismatch=False)
678 |         snap = m.snapshot()
679 |         assert snap.predictive_precision == 1.0
    |         ^^^^^^
680 |         assert snap.alignment_score == 1.0
681 |         assert snap.planner_mismatch_count == 0
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:680:9
    |
678 |         snap = m.snapshot()
679 |         assert snap.predictive_precision == 1.0
680 |         assert snap.alignment_score == 1.0
    |         ^^^^^^
681 |         assert snap.planner_mismatch_count == 0
682 |         assert not snap.violations()
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:681:9
    |
679 |         assert snap.predictive_precision == 1.0
680 |         assert snap.alignment_score == 1.0
681 |         assert snap.planner_mismatch_count == 0
    |         ^^^^^^
682 |         assert not snap.violations()
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:682:9
    |
680 |         assert snap.alignment_score == 1.0
681 |         assert snap.planner_mismatch_count == 0
682 |         assert not snap.violations()
    |         ^^^^^^
683 |
684 |     def test_degraded_metrics_detected(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:691:9
    |
689 |         snap = m.snapshot()
690 |         v = snap.violations()
691 |         assert len(v) > 0
    |         ^^^^^^
692 |
693 |     def test_empty_metrics_defaults_to_thresholds(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:695:9
    |
693 |     def test_empty_metrics_defaults_to_thresholds(self):
694 |         snap = CIL9Metrics().snapshot()
695 |         assert snap.predictive_precision == 1.0
    |         ^^^^^^
696 |         assert snap.alignment_score == 1.0
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:696:9
    |
694 |         snap = CIL9Metrics().snapshot()
695 |         assert snap.predictive_precision == 1.0
696 |         assert snap.alignment_score == 1.0
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:713:9
    |
711 |         planner = BSSPlanner("agent", "a"*64, {})
712 |         sps, score = planner.plan(self._uds())
713 |         assert len(sps.actions) > 0
    |         ^^^^^^
714 |         assert 0.0 <= score <= 1.0
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:714:9
    |
712 |         sps, score = planner.plan(self._uds())
713 |         assert len(sps.actions) > 0
714 |         assert 0.0 <= score <= 1.0
    |         ^^^^^^
715 |
716 |     def test_deterministic_same_input(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:721:9
    |
719 |         sps1, _ = planner.plan(uds)
720 |         sps2, _ = planner.plan(uds)
721 |         assert sps1.sha256() == sps2.sha256()
    |         ^^^^^^
722 |
723 |     def test_different_intent_different_sps(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:727:9
    |
725 |         sps1, _ = planner.plan(self._uds("intent-A"))
726 |         sps2, _ = planner.plan(self._uds("intent-B"))
727 |         assert sps1.sha256() != sps2.sha256()
    |         ^^^^^^
728 |
729 |     def test_replay_n100_zero_mismatches(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:732:9
    |
730 |         planner = BSSPlanner("agent", "a"*64, {})
731 |         m, n = planner.replay_n(self._uds(), n=100)
732 |         assert m == 0
    |         ^^^^^^
733 |         assert n == 100
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:733:9
    |
731 |         m, n = planner.replay_n(self._uds(), n=100)
732 |         assert m == 0
733 |         assert n == 100
    |         ^^^^^^
734 |
735 |     def test_metrics_accumulate(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:741:9
    |
739 |             planner.plan(self._uds())
740 |         snap = m.snapshot()
741 |         assert snap.predictive_precision >= 0.94
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:771:9
    |
769 |         crsm = CRSMBoundary(sha, min_replay_n=100)
770 |         ok, msg = crsm.check_kernel_integrity(sha)
771 |         assert ok
    |         ^^^^^^
772 |
773 |     def test_kernel_modification_halts(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:776:9
    |
774 |         crsm = CRSMBoundary("a"*64, min_replay_n=100)
775 |         ok, msg = crsm.check_kernel_integrity("b"*64)
776 |         assert not ok
    |         ^^^^^^
777 |         assert crsm.halted
778 |         assert "HARD-KILL" in msg
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:777:9
    |
775 |         ok, msg = crsm.check_kernel_integrity("b"*64)
776 |         assert not ok
777 |         assert crsm.halted
    |         ^^^^^^
778 |         assert "HARD-KILL" in msg
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:778:9
    |
776 |         assert not ok
777 |         assert crsm.halted
778 |         assert "HARD-KILL" in msg
    |         ^^^^^^
779 |
780 |     def test_valid_peripheral_mutation_approved(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:784:9
    |
782 |         crsm = CRSMBoundary(sha, min_replay_n=100)
783 |         ok, errors = crsm.propose_mutation(self._epoch(sha), sha)
784 |         assert ok, errors
    |         ^^^^^^
785 |
786 |     def test_non_reversible_mutation_rejected(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:792:9
    |
790 |         epoch.mutations[0].reversible = False
791 |         ok, errors = crsm.propose_mutation(epoch, sha)
792 |         assert not ok
    |         ^^^^^^
793 |
794 |     def test_unattest_mutation_rejected(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:800:9
    |
798 |         epoch.mutations[0].attested = False
799 |         ok, errors = crsm.propose_mutation(epoch, sha)
800 |         assert not ok
    |         ^^^^^^
801 |
802 |     def test_hard_kill_stops_further_mutations(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:807:9
    |
805 |         crsm.hard_kill(sha)
806 |         ok, errors = crsm.propose_mutation(self._epoch(sha), sha)
807 |         assert not ok
    |         ^^^^^^
808 |         assert any("halted" in e for e in errors)
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:808:9
    |
806 |         ok, errors = crsm.propose_mutation(self._epoch(sha), sha)
807 |         assert not ok
808 |         assert any("halted" in e for e in errors)
    |         ^^^^^^
809 |
810 |     def test_commit_produces_ci_l10_snapshot(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:814:9
    |
812 |         crsm = CRSMBoundary(sha, min_replay_n=100)
813 |         snap = crsm.commit_epoch(self._epoch(sha), sha)
814 |         assert snap.invariant_integrity == 1.0
    |         ^^^^^^
815 |         assert snap.optimization_delta == pytest.approx(0.20)
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:815:9
    |
813 |         snap = crsm.commit_epoch(self._epoch(sha), sha)
814 |         assert snap.invariant_integrity == 1.0
815 |         assert snap.optimization_delta == pytest.approx(0.20)
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:825:9
    |
823 |     def test_baseline_has_controls(self):
824 |         m = SSdfControlMap()
825 |         assert len(m._controls) > 0
    |         ^^^^^^
826 |
827 |     def test_satisfy_marks_control(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:830:9
    |
828 |         m = SSdfControlMap()
829 |         ok = m.satisfy("SSDF-P.1.1", evidence_ref="REF:DOC#policy#"+"0"*64)
830 |         assert ok
    |         ^^^^^^
831 |         c = next(x for x in m._controls if x.control_id == "SSDF-P.1.1")
832 |         assert c.satisfied
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:832:9
    |
830 |         assert ok
831 |         c = next(x for x in m._controls if x.control_id == "SSDF-P.1.1")
832 |         assert c.satisfied
    |         ^^^^^^
833 |
834 |     def test_coverage_increases_on_satisfy(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:838:9
    |
836 |         cov0 = m.coverage()
837 |         m.satisfy("SSDF-P.1.1")
838 |         assert m.coverage() > cov0
    |         ^^^^^^
839 |
840 |     def test_regression_guard_detects_regression(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:849:9
    |
847 |                 c.satisfied = False
848 |                 break
849 |         assert m.has_regression()
    |         ^^^^^^
850 |
851 |     def test_no_regression_when_guard_disabled(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:853:9
    |
851 |     def test_no_regression_when_guard_disabled(self):
852 |         m = SSdfControlMap()
853 |         assert not m.has_regression()
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:859:9
    |
857 |     def test_default_contract_populated(self):
858 |         c = build_default_phase_g_contract()
859 |         assert c.is_populated()
    |         ^^^^^^
860 |
861 |     def test_empty_contract_not_populated(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:871:9
    |
869 |             rollback_conditions=[],
870 |         )
871 |         assert not c.is_populated()
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:877:9
    |
875 |     def test_all_pending_initially(self):
876 |         t = TelemetryInitializer()
877 |         assert not t.execution_ready
    |         ^^^^^^
878 |         assert t.autonomy_status == "AUTONOMY_OFF"
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:878:9
    |
876 |         t = TelemetryInitializer()
877 |         assert not t.execution_ready
878 |         assert t.autonomy_status == "AUTONOMY_OFF"
    |         ^^^^^^
879 |
880 |     def test_run_check_marks_status(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:883:9
    |
881 |         t = TelemetryInitializer()
882 |         t.run_check("T0", lambda: (True, "test evidence"))
883 |         assert t._checks["T0"].status == "PASS"
    |         ^^^^^^
884 |
885 |     def test_failing_check_blocks_execution(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:890:9
    |
888 |             t.mark(cid, status="PASS")
889 |         t.mark("T7", status="FAIL")
890 |         assert not t.execution_ready
    |         ^^^^^^
891 |
892 |     def test_all_pass_gives_hardened_determinism(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:896:9
    |
894 |         for cid in ["T0","T1","T2","T3","T4","T5","T6","T7"]:
895 |             t.mark(cid, status="PASS")
896 |         assert t.execution_ready
    |         ^^^^^^
897 |         assert t.autonomy_status == "HARDENED_DETERMINISM"
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:897:9
    |
895 |             t.mark(cid, status="PASS")
896 |         assert t.execution_ready
897 |         assert t.autonomy_status == "HARDENED_DETERMINISM"
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:907:9
    |
905 |     def test_bootstrap_creates_state_dir(self, tmp_path):
906 |         rt = AD2026Runtime.bootstrap(root=str(tmp_path))
907 |         assert os.path.isdir(str(tmp_path / "ad2026_state"))
    |         ^^^^^^
908 |
909 |     def test_bootstrap_generates_ac_root_key(self, tmp_path):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:911:9
    |
909 |     def test_bootstrap_generates_ac_root_key(self, tmp_path):
910 |         AD2026Runtime.bootstrap(root=str(tmp_path))
911 |         assert os.path.exists(str(tmp_path / "ad2026_state" / "AC_ROOT_KEY.json"))
    |         ^^^^^^
912 |
913 |     def test_bootstrap_key_reused_on_second_call(self, tmp_path):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:916:9
    |
914 |         rt1 = AD2026Runtime.bootstrap(root=str(tmp_path))
915 |         rt2 = AD2026Runtime.bootstrap(root=str(tmp_path))
916 |         assert rt1.ac.sha256() == rt2.ac.sha256()
    |         ^^^^^^
917 |
918 |     def test_telemetry_checklist_all_pass(self, runtime):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:920:9
    |
918 |     def test_telemetry_checklist_all_pass(self, runtime):
919 |         result = runtime.run_telemetry_checklist()
920 |         assert result["execution_ready"], result["checks"]
    |         ^^^^^^
921 |         for cid, check in result["checks"].items():
922 |             assert check["status"] == "PASS", f"{cid} FAILED: {check['evidence']}"
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:922:13
    |
920 |         assert result["execution_ready"], result["checks"]
921 |         for cid, check in result["checks"].items():
922 |             assert check["status"] == "PASS", f"{cid} FAILED: {check['evidence']}"
    |             ^^^^^^
923 |
924 |     def test_execute_sps_nominal_all_gates_pass(self, runtime, sample_sps):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:937:9
    |
935 |             runtime.run_telemetry_checklist()
936 |             result = runtime.execute_sps(sample_sps)
937 |         assert result["execution_allowed"] is True, f"Gates failed: {result.get('gate_reports')}"
    |         ^^^^^^
938 |         for gate in result["gates"]["gates"]:
939 |             assert gate["status"] == "PASS", gate
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:939:13
    |
937 |         assert result["execution_allowed"] is True, f"Gates failed: {result.get('gate_reports')}"
938 |         for gate in result["gates"]["gates"]:
939 |             assert gate["status"] == "PASS", gate
    |             ^^^^^^
940 |
941 |     def test_execute_sps_writes_log(self, runtime, sample_sps):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:945:9
    |
943 |         runtime.execute_sps(sample_sps)
944 |         log_path = os.path.join(runtime.state_dir, "AD2026_EXECUTION_LOG.jsonl")
945 |         assert os.path.exists(log_path)
    |         ^^^^^^
946 |         with open(log_path) as f:
947 |             entry = json.loads(f.readlines()[-1])
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:948:9
    |
946 |         with open(log_path) as f:
947 |             entry = json.loads(f.readlines()[-1])
948 |         assert entry["sps_id"] == sample_sps.sps_id
    |         ^^^^^^
949 |         assert entry["execution_allowed"] is True
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:949:9
    |
947 |             entry = json.loads(f.readlines()[-1])
948 |         assert entry["sps_id"] == sample_sps.sps_id
949 |         assert entry["execution_allowed"] is True
    |         ^^^^^^
950 |
951 |     def test_execute_invalid_sps_blocked(self, runtime):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:956:9
    |
954 |         bad_sps = SPS("BAD", "agent", datetime.now(tz=timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ"))
955 |         result = runtime.execute_sps(bad_sps)
956 |         assert not result["execution_allowed"]
    |         ^^^^^^
957 |         assert any(g["status"] == "FAIL" for g in result["gates"]["gates"])
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:957:9
    |
955 |         result = runtime.execute_sps(bad_sps)
956 |         assert not result["execution_allowed"]
957 |         assert any(g["status"] == "FAIL" for g in result["gates"]["gates"])
    |         ^^^^^^
958 |
959 |     def test_apb_chain_grows_on_each_execute(self, runtime, sample_sps):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:964:9
    |
962 |         runtime.execute_sps(sample_sps)
963 |         runtime.execute_sps(sample_sps)
964 |         assert len(runtime.apb_chain) == n0 + 4  # 2 pre + 2 final
    |         ^^^^^^
965 |
966 |     def test_status_written_to_file(self, runtime):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:969:9
    |
967 |         runtime.run_telemetry_checklist()
968 |         s = runtime.status()
969 |         assert os.path.exists(os.path.join(runtime.state_dir, "AD2026_STATUS.json"))
    |         ^^^^^^
970 |         assert s["grade"] == "AD-2026-INTEGRATED"
971 |         assert s["ac_version"] == "AD-2026-v2.2"
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:970:9
    |
968 |         s = runtime.status()
969 |         assert os.path.exists(os.path.join(runtime.state_dir, "AD2026_STATUS.json"))
970 |         assert s["grade"] == "AD-2026-INTEGRATED"
    |         ^^^^^^
971 |         assert s["ac_version"] == "AD-2026-v2.2"
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:971:9
    |
969 |         assert os.path.exists(os.path.join(runtime.state_dir, "AD2026_STATUS.json"))
970 |         assert s["grade"] == "AD-2026-INTEGRATED"
971 |         assert s["ac_version"] == "AD-2026-v2.2"
    |         ^^^^^^
972 |
973 |     def test_crsm_kernel_integrity_preserved(self, runtime):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:974:9
    |
973 |     def test_crsm_kernel_integrity_preserved(self, runtime):
974 |         assert not runtime.crsm.halted
    |         ^^^^^^
975 |         ok, _ = runtime.crsm.check_kernel_integrity(runtime.ac.sha256())
976 |         assert ok
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:976:9
    |
974 |         assert not runtime.crsm.halted
975 |         ok, _ = runtime.crsm.check_kernel_integrity(runtime.ac.sha256())
976 |         assert ok
    |         ^^^^^^
977 |
978 |     def test_apb_chain_verifies(self, runtime, sample_sps):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:982:9
    |
980 |         runtime.execute_sps(sample_sps)
981 |         ok, errors = runtime.apb_chain.verify_chain()
982 |         assert ok, errors
    |         ^^^^^^
983 |
984 |     def test_ssdf_coverage_after_init(self, runtime):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:986:9
    |
984 |     def test_ssdf_coverage_after_init(self, runtime):
985 |         runtime.run_telemetry_checklist()
986 |         assert runtime.ssdf_map.coverage() > 0.0
    |         ^^^^^^
987 |
988 |     def test_phase_g_populated(self, runtime):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_ad2026.py:989:9
    |
988 |     def test_phase_g_populated(self, runtime):
989 |         assert runtime.phase_g.is_populated()
    |         ^^^^^^
    |

S101 Use of `assert` detected
  --> udgs_core/tests/test_udgs_core.py:33:9
   |
31 | class TestSha256Bytes:
32 |     def test_known_vector_empty(self):
33 |         assert sha256_bytes(b"") == "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
   |         ^^^^^^
34 |
35 |     def test_known_vector_abc(self):
   |

S101 Use of `assert` detected
  --> udgs_core/tests/test_udgs_core.py:37:9
   |
35 |     def test_known_vector_abc(self):
36 |         # SHA-256("abc")  Python hashlib verified
37 |         assert sha256_bytes(b"abc") == "ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad"
   |         ^^^^^^
38 |
39 |     def test_length_always_64(self):
   |

S101 Use of `assert` detected
  --> udgs_core/tests/test_udgs_core.py:41:13
   |
39 |     def test_length_always_64(self):
40 |         for n in range(0, 300, 37):
41 |             assert len(sha256_bytes(bytes(n))) == 64
   |             ^^^^^^
42 |
43 |     def test_deterministic(self):
   |

S101 Use of `assert` detected
  --> udgs_core/tests/test_udgs_core.py:45:9
   |
43 |     def test_deterministic(self):
44 |         data = b"test payload 123"
45 |         assert sha256_bytes(data) == sha256_bytes(data)
   |         ^^^^^^
46 |
47 |     def test_avalanche(self):
   |

S101 Use of `assert` detected
  --> udgs_core/tests/test_udgs_core.py:50:9
   |
48 |         msg = b"axl udgs payload"
49 |         msg2 = msg[:-1] + bytes([msg[-1] ^ 0x01])
50 |         assert sha256_bytes(msg) != sha256_bytes(msg2)
   |         ^^^^^^
51 |         diffs = sum(a != b for a, b in zip(sha256_bytes(msg), sha256_bytes(msg2)))
52 |         assert diffs > 20
   |

S101 Use of `assert` detected
  --> udgs_core/tests/test_udgs_core.py:52:9
   |
50 |         assert sha256_bytes(msg) != sha256_bytes(msg2)
51 |         diffs = sum(a != b for a, b in zip(sha256_bytes(msg), sha256_bytes(msg2)))
52 |         assert diffs > 20
   |         ^^^^^^
   |

S101 Use of `assert` detected
  --> udgs_core/tests/test_udgs_core.py:59:9
   |
57 |         a = {"z": 1, "a": 2, "m": {"b": 3}}
58 |         b = {"a": 2, "m": {"b": 3}, "z": 1}
59 |         assert sha256_json(a) == sha256_json(b)
   |         ^^^^^^
60 |
61 |     def test_different_values_differ(self):
   |

S101 Use of `assert` detected
  --> udgs_core/tests/test_udgs_core.py:62:9
   |
61 |     def test_different_values_differ(self):
62 |         assert sha256_json({"x": 1}) != sha256_json({"x": 2})
   |         ^^^^^^
63 |
64 |     def test_list_order_matters(self):
   |

S101 Use of `assert` detected
  --> udgs_core/tests/test_udgs_core.py:65:9
   |
64 |     def test_list_order_matters(self):
65 |         assert sha256_json({"a": [1, 2]}) != sha256_json({"a": [2, 1]})
   |         ^^^^^^
66 |
67 |     def test_deep_nesting(self):
   |

S101 Use of `assert` detected
  --> udgs_core/tests/test_udgs_core.py:74:9
   |
72 |             cur = cur["n"]
73 |         h = sha256_json(obj)
74 |         assert len(h) == 64
   |         ^^^^^^
75 |
76 |     def test_collision_resistant(self):
   |

S101 Use of `assert` detected
  --> udgs_core/tests/test_udgs_core.py:83:13
   |
81 |         ]
82 |         for o1, o2 in pairs:
83 |             assert sha256_json(o1) != sha256_json(o2), f"Collision: {o1}"
   |             ^^^^^^
   |

S101 Use of `assert` detected
  --> udgs_core/tests/test_udgs_core.py:92:9
   |
90 |         h1 = sha256_file(str(f))
91 |         h2 = sha256_file(str(f))
92 |         assert h1 == h2
   |         ^^^^^^
93 |         assert len(h1) == 64
   |

S101 Use of `assert` detected
  --> udgs_core/tests/test_udgs_core.py:93:9
   |
91 |         h2 = sha256_file(str(f))
92 |         assert h1 == h2
93 |         assert len(h1) == 64
   |         ^^^^^^
94 |
95 |     def test_content_sensitivity(self, tmp_path):
   |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:100:9
    |
 98 |         g = tmp_path / "b.txt"
 99 |         g.write_bytes(b"content_b")
100 |         assert sha256_file(str(f)) != sha256_file(str(g))
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:110:9
    |
108 |         h1, _ = sha256_tree(str(d1))
109 |         h2, _ = sha256_tree(str(d2))
110 |         assert h1 == h2
    |         ^^^^^^
111 |
112 |     def test_idempotent_10x(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:114:9
    |
112 |     def test_idempotent_10x(self):
113 |         hashes = [sha256_tree(os.path.join(ROOT, "engine"))[0] for _ in range(10)]
114 |         assert len(set(hashes)) == 1
    |         ^^^^^^
115 |
116 |     def test_file_change_detected(self, tmp_path):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:122:9
    |
120 |         f.write_text("modified")
121 |         h2, _ = sha256_tree(str(tmp_path))
122 |         assert h1 != h2
    |         ^^^^^^
123 |
124 |     def test_exclude_rel_paths(self, tmp_path):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:129:9
    |
127 |         h_with, _ = sha256_tree(str(tmp_path))
128 |         h_without, _ = sha256_tree(str(tmp_path), exclude_rel_paths={"exclude.txt"})
129 |         assert h_with != h_without
    |         ^^^^^^
130 |
131 |     def test_returns_file_hashes_dict(self, tmp_path):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:135:9
    |
133 |         (tmp_path / "b.txt").write_text("b")
134 |         _, files = sha256_tree(str(tmp_path))
135 |         assert "a.txt" in files
    |         ^^^^^^
136 |         assert "b.txt" in files
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:136:9
    |
134 |         _, files = sha256_tree(str(tmp_path))
135 |         assert "a.txt" in files
136 |         assert "b.txt" in files
    |         ^^^^^^
137 |
138 |     def test_path_traversal_normalized(self, tmp_path):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:142:9
    |
140 |         h1, _ = sha256_tree(str(tmp_path))
141 |         h2, _ = sha256_tree(str(tmp_path / ".." / tmp_path.name))
142 |         assert h1 == h2
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:159:9
    |
157 |         c = DeterministicCycle(fail_closed=True)
158 |         ev = self._good_ev()
159 |         assert c.step(ev).next_state == LoopState.FIX
    |         ^^^^^^
160 |         assert c.step(ev).next_state == LoopState.PROVE
161 |         assert c.step(ev).next_state == LoopState.CHECKPOINT
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:160:9
    |
158 |         ev = self._good_ev()
159 |         assert c.step(ev).next_state == LoopState.FIX
160 |         assert c.step(ev).next_state == LoopState.PROVE
    |         ^^^^^^
161 |         assert c.step(ev).next_state == LoopState.CHECKPOINT
162 |         assert c.step(ev).next_state == LoopState.FAIL  # wraps
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:161:9
    |
159 |         assert c.step(ev).next_state == LoopState.FIX
160 |         assert c.step(ev).next_state == LoopState.PROVE
161 |         assert c.step(ev).next_state == LoopState.CHECKPOINT
    |         ^^^^^^
162 |         assert c.step(ev).next_state == LoopState.FAIL  # wraps
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:162:9
    |
160 |         assert c.step(ev).next_state == LoopState.PROVE
161 |         assert c.step(ev).next_state == LoopState.CHECKPOINT
162 |         assert c.step(ev).next_state == LoopState.FAIL  # wraps
    |         ^^^^^^
163 |
164 |     def test_halt_on_missing_logs(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:169:9
    |
167 |         c.step(ev); c.step(ev)
168 |         r = c.step(ev)
169 |         assert r.next_state == LoopState.HALT
    |         ^^^^^^
170 |
171 |     def test_halt_on_missing_anchor(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:175:9
    |
173 |         ev = Evidence(logs={"x": 1}, hash_anchor=None)
174 |         c.step(ev); c.step(ev)
175 |         assert c.step(ev).next_state == LoopState.HALT
    |         ^^^^^^
176 |
177 |     def test_halt_on_oracle_false(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:181:9
    |
179 |         ev = Evidence(logs={"x": 1}, hash_anchor="abc", oracle_pass=False)
180 |         c.step(ev); c.step(ev)
181 |         assert c.step(ev).next_state == LoopState.HALT
    |         ^^^^^^
182 |
183 |     def test_halt_is_absorbing(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:190:13
    |
188 |         for _ in range(30):
189 |             r = c.step(self._good_ev())
190 |             assert r.next_state == LoopState.HALT
    |             ^^^^^^
191 |
192 |     def test_history_completeness(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:197:9
    |
195 |         for _ in range(8):
196 |             c.step(ev)
197 |         assert len(c.history) == 8
    |         ^^^^^^
198 |
199 |     def test_violated_invariants_populated(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:204:9
    |
202 |         c.step(ev_bad); c.step(ev_bad)
203 |         r = c.step(ev_bad)
204 |         assert len(r.violated) >= 2
    |         ^^^^^^
205 |
206 |     def test_notes_nonempty(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:210:9
    |
208 |         ev = self._good_ev()
209 |         r = c.step(ev)
210 |         assert len(r.notes) > 0
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:236:9
    |
234 |     def test_valid_packet_ok(self):
235 |         ok, errs = validate_packet(_valid_packet())
236 |         assert ok, str(errs)
    |         ^^^^^^
237 |
238 |     def test_missing_top_level_key_fails(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:242:9
    |
240 |         del p["MUTATION_PLAN"]
241 |         ok, _ = validate_packet(p)
242 |         assert not ok
    |         ^^^^^^
243 |
244 |     def test_extra_top_level_key_rejected(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:250:9
    |
248 |         # extra key still fails
249 |         ok, _ = validate_packet(p)
250 |         assert not ok
    |         ^^^^^^
251 |
252 |     def test_anchor_mismatch_rejected(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:256:9
    |
254 |         p["SHA256_ANCHOR"] = "a" * 64
255 |         ok, errs = validate_packet(p)
256 |         assert not ok
    |         ^^^^^^
257 |         assert any("Anchor mismatch" in e.message for e in errs)
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:257:9
    |
255 |         ok, errs = validate_packet(p)
256 |         assert not ok
257 |         assert any("Anchor mismatch" in e.message for e in errs)
    |         ^^^^^^
258 |
259 |     def test_uppercase_anchor_rejected(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:263:9
    |
261 |         p["SHA256_ANCHOR"] = "A" * 64
262 |         ok, _ = validate_packet(p)
263 |         assert not ok
    |         ^^^^^^
264 |
265 |     def test_empty_signals_rejected(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:269:9
    |
267 |         p["FAIL_PACKET"]["signals"] = []
268 |         ok, _ = validate_packet(p)
269 |         assert not ok
    |         ^^^^^^
270 |
271 |     def test_empty_summary_rejected(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:275:9
    |
273 |         p["FAIL_PACKET"]["summary"] = "   "
274 |         ok, _ = validate_packet(p)
275 |         assert not ok
    |         ^^^^^^
276 |
277 |     def test_empty_expected_rejected(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:281:9
    |
279 |         p["REGRESSION_TEST_PAYLOAD"]["expected"] = {}
280 |         ok, _ = validate_packet(p)
281 |         assert not ok
    |         ^^^^^^
282 |
283 |     def test_anchor_self_consistent_after_roundtrip(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:286:9
    |
284 |         p = _valid_packet()
285 |         anchor = compute_packet_anchor(p)
286 |         assert p["SHA256_ANCHOR"] == anchor
    |         ^^^^^^
287 |
288 |     def test_large_packet_accepted(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:294:9
    |
292 |         p["SHA256_ANCHOR"] = compute_packet_anchor(p)
293 |         ok, errs = validate_packet(p)
294 |         assert ok, str(errs)
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:315:9
    |
313 |         pkt = proof_bundle_to_udgs_packet(self._bundle("success"), pre_verification_script="make check")
314 |         ok, errs = validate_packet(pkt)
315 |         assert ok, str(errs)
    |         ^^^^^^
316 |
317 |     @pytest.mark.parametrize("status", ["success", "failure", "pending", "skipped"])
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:321:9
    |
319 |         pkt = proof_bundle_to_udgs_packet(self._bundle(status), pre_verification_script="run")
320 |         ok, errs = validate_packet(pkt)
321 |         assert ok, f"status={status}: {errs}"
    |         ^^^^^^
322 |
323 |     def test_unknown_status_raises(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:335:9
    |
333 |         import re
334 |         pkt = proof_bundle_to_udgs_packet(self._bundle(), pre_verification_script="r")
335 |         assert re.match(r"^[a-f0-9]{64}$", pkt["SHA256_ANCHOR"])
    |         ^^^^^^
336 |
337 |     def test_packet_has_required_regression_keys(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:340:9
    |
338 |         pkt = proof_bundle_to_udgs_packet(self._bundle(), pre_verification_script="r")
339 |         rp = pkt["REGRESSION_TEST_PAYLOAD"]
340 |         assert "suite" in rp and len(rp["suite"]) > 0
    |         ^^^^^^
341 |         assert "expected" in rp and len(rp["expected"]) > 0
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:341:9
    |
339 |         rp = pkt["REGRESSION_TEST_PAYLOAD"]
340 |         assert "suite" in rp and len(rp["suite"]) > 0
341 |         assert "expected" in rp and len(rp["expected"]) > 0
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:405:9
    |
403 |         eng.load_baseline()
404 |         status = eng.run_cycle()
405 |         assert status.mode == Qa8Mode.NOMINAL
    |         ^^^^^^
406 |         assert status.baseline_anchor == status.live_anchor
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:406:9
    |
404 |         status = eng.run_cycle()
405 |         assert status.mode == Qa8Mode.NOMINAL
406 |         assert status.baseline_anchor == status.live_anchor
    |         ^^^^^^
407 |
408 |     def test_grade_is_qa8(self, tmp_path):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:412:9
    |
410 |         eng.load_baseline()
411 |         status = eng.run_cycle()
412 |         assert status.grade == QA8_GRADE
    |         ^^^^^^
413 |
414 |     def test_source_drift_triggers_alert(self, tmp_path):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:419:9
    |
417 |         (tmp_path / "engine" / "injected.py").write_text("# drift")
418 |         status = eng.run_cycle()
419 |         assert status.mode in (Qa8Mode.ALERT, Qa8Mode.HEALED)
    |         ^^^^^^
420 |
421 |     def test_status_file_written(self, tmp_path):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:425:9
    |
423 |         eng.load_baseline()
424 |         eng.run_cycle()
425 |         assert (tmp_path / "qa8_state" / "QA8_STATUS.json").exists()
    |         ^^^^^^
426 |
427 |     def test_heal_log_written_on_drift(self, tmp_path):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:433:9
    |
431 |         eng.run_cycle()
432 |         log = tmp_path / "qa8_state" / "HEAL_LOG.jsonl"
433 |         assert log.exists()
    |         ^^^^^^
434 |         lines = log.read_text().strip().splitlines()
435 |         assert len(lines) > 0
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:435:9
    |
433 |         assert log.exists()
434 |         lines = log.read_text().strip().splitlines()
435 |         assert len(lines) > 0
    |         ^^^^^^
436 |         event = json.loads(lines[-1])
437 |         assert all(k in event for k in ("event_id", "drifts", "outcome", "utc"))
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:437:9
    |
435 |         assert len(lines) > 0
436 |         event = json.loads(lines[-1])
437 |         assert all(k in event for k in ("event_id", "drifts", "outcome", "utc"))
    |         ^^^^^^
438 |
439 |     def test_scan_count_increments(self, tmp_path):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:444:13
    |
442 |         for i in range(1, 6):
443 |             status = eng.run_cycle()
444 |             assert status.scan_count == i
    |             ^^^^^^
445 |
446 |     def test_missing_component_reported_as_drift(self, tmp_path):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:454:9
    |
452 |         drifts = eng.detect_drift()
453 |         ghost_drifts = [d for d in drifts if d.name == "GHOST"]
454 |         assert len(ghost_drifts) == 1
    |         ^^^^^^
455 |         assert ghost_drifts[0].live_hash == "MISSING"
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:455:9
    |
453 |         ghost_drifts = [d for d in drifts if d.name == "GHOST"]
454 |         assert len(ghost_drifts) == 1
455 |         assert ghost_drifts[0].live_hash == "MISSING"
    |         ^^^^^^
456 |
457 |     def test_watch_terminates_on_max_cycles(self, tmp_path):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:462:9
    |
460 |         eng.watch(interval_sec=0.0, max_cycles=5)
461 |         status_data = json.loads((tmp_path / "qa8_state" / "QA8_STATUS.json").read_text())
462 |         assert status_data["scan_count"] == 5
    |         ^^^^^^
463 |
464 |     def test_auto_loads_baseline_in_run_cycle(self, tmp_path):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:468:9
    |
466 |         # Do NOT call load_baseline()
467 |         status = eng.run_cycle()  # must auto-load
468 |         assert status.mode == Qa8Mode.NOMINAL
    |         ^^^^^^
469 |
470 |     def test_status_schema_complete(self, tmp_path):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:477:13
    |
475 |         for key in ("mode", "last_scan_utc", "scan_count", "heal_count",
476 |                     "alert_count", "halt_count", "baseline_anchor", "live_anchor", "grade"):
477 |             assert key in d, f"Missing key: {key}"
    |             ^^^^^^
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:484:9
    |
482 |         baseline = {"components": {"A": {"hash": "aaa"}, "B": {"hash": "bbb"}}}
483 |         result = score_system(baseline, {"A": "aaa", "B": "bbb"})
484 |         assert result["integrity_score"] == 1.0
    |         ^^^^^^
485 |         assert result["grade"] == "PASS"
486 |         assert result["drifted"] == 0
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:485:9
    |
483 |         result = score_system(baseline, {"A": "aaa", "B": "bbb"})
484 |         assert result["integrity_score"] == 1.0
485 |         assert result["grade"] == "PASS"
    |         ^^^^^^
486 |         assert result["drifted"] == 0
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:486:9
    |
484 |         assert result["integrity_score"] == 1.0
485 |         assert result["grade"] == "PASS"
486 |         assert result["drifted"] == 0
    |         ^^^^^^
487 |
488 |     def test_degraded_score(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:492:9
    |
490 |         live = {f"C{i}": ("CHANGED" if i < 2 else f"h{i}") for i in range(4)}
491 |         result = score_system(baseline, live)
492 |         assert result["grade"] == "DEGRADED"
    |         ^^^^^^
493 |         assert result["drifted"] == 2
494 |         assert abs(result["integrity_score"] - 0.5) < 0.001
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:493:9
    |
491 |         result = score_system(baseline, live)
492 |         assert result["grade"] == "DEGRADED"
493 |         assert result["drifted"] == 2
    |         ^^^^^^
494 |         assert abs(result["integrity_score"] - 0.5) < 0.001
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:494:9
    |
492 |         assert result["grade"] == "DEGRADED"
493 |         assert result["drifted"] == 2
494 |         assert abs(result["integrity_score"] - 0.5) < 0.001
    |         ^^^^^^
495 |
496 |     def test_empty_baseline_perfect(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:498:9
    |
496 |     def test_empty_baseline_perfect(self):
497 |         result = score_system({"components": {}}, {})
498 |         assert result["integrity_score"] == 1.0
    |         ^^^^^^
499 |
500 |     def test_thread_safety(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:509:9
    |
507 |         for t in threads: t.start()
508 |         for t in threads: t.join()
509 |         assert all(s == 1.0 for s in results)
    |         ^^^^^^
    |

S603 `subprocess` call: check for execution of untrusted input
   --> udgs_core/tests/test_udgs_core.py:518:16
    |
516 | class TestCLI:
517 |     def _run(self, *args):
518 |         return subprocess.run(
    |                ^^^^^^^^^^^^^^
519 |             [sys.executable, "-m", "udgs_core.cli"] + list(args),
520 |             capture_output=True, text=True, cwd=ROOT
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:527:9
    |
525 |         f.write_bytes(b"hello")
526 |         r = self._run("anchor", str(f))
527 |         assert r.returncode == 0
    |         ^^^^^^
528 |         assert len(r.stdout.strip()) == 64
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:528:9
    |
526 |         r = self._run("anchor", str(f))
527 |         assert r.returncode == 0
528 |         assert len(r.stdout.strip()) == 64
    |         ^^^^^^
529 |
530 |     def test_anchor_dir(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:532:9
    |
530 |     def test_anchor_dir(self):
531 |         r = self._run("anchor", "engine")
532 |         assert r.returncode == 0
    |         ^^^^^^
533 |         assert len(r.stdout.strip()) == 64
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:533:9
    |
531 |         r = self._run("anchor", "engine")
532 |         assert r.returncode == 0
533 |         assert len(r.stdout.strip()) == 64
    |         ^^^^^^
534 |
535 |     def test_validate_packet_valid(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:537:9
    |
535 |     def test_validate_packet_valid(self):
536 |         r = self._run("validate-packet", "system/examples/packet.example.json")
537 |         assert r.returncode == 0
    |         ^^^^^^
538 |         assert r.stdout.strip() == "OK"
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:538:9
    |
536 |         r = self._run("validate-packet", "system/examples/packet.example.json")
537 |         assert r.returncode == 0
538 |         assert r.stdout.strip() == "OK"
    |         ^^^^^^
539 |
540 |     def test_validate_packet_invalid_anchor(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:542:9
    |
540 |     def test_validate_packet_invalid_anchor(self):
541 |         r = self._run("validate-packet", "system/examples/packet.invalid.anchor_mismatch.json")
542 |         assert r.returncode != 0
    |         ^^^^^^
543 |
544 |     def test_validate_packet_invalid_extra_key(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:546:9
    |
544 |     def test_validate_packet_invalid_extra_key(self):
545 |         r = self._run("validate-packet", "system/examples/packet.invalid.extra_key.json")
546 |         assert r.returncode != 0
    |         ^^^^^^
547 |
548 |     def test_build_system_object(self, tmp_path):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:553:9
    |
551 |                       "--config", os.path.join(ROOT, "system/udgs.config.json"),
552 |                       "--out", str(out))
553 |         assert r.returncode == 0
    |         ^^^^^^
554 |         assert len(r.stdout.strip()) == 64  # prints system_anchor
555 |         so = json.loads(out.read_text())
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:554:9
    |
552 |                       "--out", str(out))
553 |         assert r.returncode == 0
554 |         assert len(r.stdout.strip()) == 64  # prints system_anchor
    |         ^^^^^^
555 |         so = json.loads(out.read_text())
556 |         assert "system_anchor" in so
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:556:9
    |
554 |         assert len(r.stdout.strip()) == 64  # prints system_anchor
555 |         so = json.loads(out.read_text())
556 |         assert "system_anchor" in so
    |         ^^^^^^
557 |         assert "components" in so
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:557:9
    |
555 |         so = json.loads(out.read_text())
556 |         assert "system_anchor" in so
557 |         assert "components" in so
    |         ^^^^^^
558 |
559 |     def test_build_system_object_deterministic(self, tmp_path):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:568:9
    |
566 |                        "--config", os.path.join(ROOT, "system/udgs.config.json"),
567 |                        "--out", str(out2))
568 |         assert r1.stdout.strip() == r2.stdout.strip()
    |         ^^^^^^
569 |
570 |     def test_qa8_heal_nominal(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:576:9
    |
574 |                   "--out", os.path.join(ROOT, "SYSTEM_OBJECT.json"))
575 |         r = self._run("qa8-heal", "--root", ROOT)
576 |         assert r.returncode == 0
    |         ^^^^^^
577 |         result = json.loads(r.stdout)
578 |         assert result["mode"] == "NOMINAL"
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:578:9
    |
576 |         assert r.returncode == 0
577 |         result = json.loads(r.stdout)
578 |         assert result["mode"] == "NOMINAL"
    |         ^^^^^^
579 |         assert result["grade"].startswith("QA8")
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:579:9
    |
577 |         result = json.loads(r.stdout)
578 |         assert result["mode"] == "NOMINAL"
579 |         assert result["grade"].startswith("QA8")
    |         ^^^^^^
580 |
581 |     def test_qa8_status_file_readable(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:583:9
    |
581 |     def test_qa8_status_file_readable(self):
582 |         r = self._run("qa8-status", "--root", ROOT)
583 |         assert r.returncode == 0
    |         ^^^^^^
584 |         data = json.loads(r.stdout)
585 |         assert "mode" in data and "grade" in data
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:585:9
    |
583 |         assert r.returncode == 0
584 |         data = json.loads(r.stdout)
585 |         assert "mode" in data and "grade" in data
    |         ^^^^^^
586 |
587 |     def test_loop_nominal(self, tmp_path):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:591:9
    |
589 |         ev.write_text(json.dumps({"logs": {"x": 1}, "hash_anchor": "abc", "oracle_pass": True}))
590 |         r = self._run("loop", "--evidence-json", str(ev))
591 |         assert r.returncode == 0
    |         ^^^^^^
592 |         result = json.loads(r.stdout)
593 |         assert result["next_state"] == "CHECKPOINT"
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:593:9
    |
591 |         assert r.returncode == 0
592 |         result = json.loads(r.stdout)
593 |         assert result["next_state"] == "CHECKPOINT"
    |         ^^^^^^
594 |
595 |     def test_loop_halt_on_no_evidence(self):
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:597:9
    |
595 |     def test_loop_halt_on_no_evidence(self):
596 |         r = self._run("loop")
597 |         assert r.returncode != 0
    |         ^^^^^^
598 |         result = json.loads(r.stdout)
599 |         assert result["next_state"] == "HALT"
    |

S101 Use of `assert` detected
   --> udgs_core/tests/test_udgs_core.py:599:9
    |
597 |         assert r.returncode != 0
598 |         result = json.loads(r.stdout)
599 |         assert result["next_state"] == "HALT"
    |         ^^^^^^
    |

Found 776 errors.
